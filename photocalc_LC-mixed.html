<!DOCTYPE html>
<html>
<head>
  <title>Moon ephemeris for photographers</title>

  <meta charset="utf-8" />

<!--
Astrophotography ephemeris calculator bu Luca Cassioli

v.0.12.0
- Added url parameters management

v.0.11.0 
- Fixed bug of azimuth, it was in Meeus library, which calculated it from South
- Added dynamic links to mooncalc
- Added "loader" overlay until all tiles are loaded
- Fixed bug of error message printed upon clicking buttons in table lines
- Changed Cesium time to local
- Added height and zoom values to interface
- Removed button "C" from lines (to copy data to manual input form)

v.0.10.0 Fixed sunset/sunrise timings bug (GMT/local) for moon and sun, also in meeus library

v.0.9.0 Mapbox to openStreetMap


v. 0.8.0m
- Using MeeusJS for moon and sun positions
- Uniformed colors of selected lines and rows
- Removed Cesium animation (flyto/setview)
- Fixed (?) UTC/local bugs
- Added buttons to table
- Added Sun button to point Sun
- Added 3d lines to sun/moon
- Reduced GUI width by restructuring
- Put locations list inside SELECT/OPTION structure

V.0.7.0m
- Both original SunCalc library and derived ones give wrong values for moon;
swithcing to german algotithm converted to library: https://www.dannybekaert.be/en/moonposition
Other possibility: Real library "https://github.com/Fabiz/MeeusJs" based on Meeus paper.
- Fixed lookAtMoon button and various functions related to Moon position.
- Messing up with 3d lines pointing to moon and sun, to be fixed.

V.0.6.0m
- removed markers: lines are enough
- fixed bug of line not permanently highlighted upon clicking
- removed buttons from popup
- working on 3d moon/sun pointer
- locations lines made thinner; todo: add labels/tooltips for each line on map border, remove tooltip and clickability
- added permanent tooltips to location lines, both when visible and not

V. 0.5.0m
- Added pitch/heading information for myLocations
- Added slider/buttons for height
- Added location tracking
- Added altitude lock while tracking
- Added buttons to go to location or point to location

V. 0.4.0m
- Better image for compass
- Added loading external locations
- Added lines for external locations
- Added empty  results table at page opening
- Made observer marker draggable
- Removed schematic/drawings for rsults
- Addded tooltip to lines and markers
- todo:
-   fix bug of bad camera line if camera is pointing to sky/moon
-   add location selection before clicking on map, to automatically set azimuth input range
-   reimplement "fly to location" function upon clicking location
-   turn locations list into interactive table
-   implement "poin to" buttons (need to implement/fix camera/target heights)
-   add checkboxes to hide location lines and compass
-   add realtime display of mouse pointer azimuth w.r.t map center and w.r.t observer


V. 0.3.0 mixed
- Restructured results table (centered results, embedded date in header)
- Added leading zeroes to hours/mins
- Added compass on 2d map
- Added line pointing to moon
- Lines made clickable
- Text results made clickable
- Added camera direction line in 2d map
- Added cross at center of 3d view
- Fixed zoom buttons/slider
- Added 2d to 3d sync as option



V. 0.2.0 mixed
- Added moon finder
- Added immediate buttons in popups
- Removed coordinates in Cesium format from GUI, only Google format is used now
- Added realtima GPS moon tracking
- Clickable markers and lines for position/orientation

V. 0.1.0 mixed
- Mixed map (Leaflet) and 3d (cesium) views
- Synced 2d map to 3d view
- Reordered input for map
- Added "copy position from 2d to 3d"
- Added table for output


V 0.1.0
- Added location data to GUI
- Added link to exposure calculator
- Added schematics of Sun and Moon altitude and Phase
- Added button to clear the map
- Added sunrise/sunset times


V.0.0.3
- Added location coordinates in console output (in both formats for Google and CesiumJS)
- Added configurable length of lines (currently hardcoded to 100 km)
- Added configurable start date


V.0.0.2: Everything is working. To do:
- add interactive text output
- add sliders for inputs
- make marker movable

V.0.0.1: First working version. To do:
- add marker for each calculated position


-->


	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta charset="utf-8">
	<link rel="shortcut icon" type="image/x-icon" href="docs/images/favicon.ico" />
	<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==" crossorigin=""/>
	<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js" integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==" crossorigin=""></script>
	<!--<script src="https://unpkg.com/leaflet-center-cross@0.0.8/dist/leaflet.CenterCross.js"></script>-->
	<script src="leaflet.circle-sector.js"></script>
	<script src="https://cesium.com/downloads/cesiumjs/releases/1.80/Build/Cesium/Cesium.js"></script>
	<link href="https://cesium.com/downloads/cesiumjs/releases/1.80/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
	 <link rel="stylesheet" href="photocalc-overlay.css"> <!-- Per overlay di caricamento -->
	<script src="https://cdn.jsdelivr.net/npm/luxon@1.25.0/build/global/luxon.min.js"></script> <!-- per orario locale in cesium-->
	<!--<script src = "astronomy.browser.js"></script>-->

	<script src = "meuusjs.1.0.4.min.js"></script>
	<script src = "meeus-easy.js"></script>
	<script src="mylocations.js"></script>

</head>

<body>
    <!-- Contenitore per l'overlay di caricamento -->
    <div id="overlay" class="overlay">
        <div class="loader"></div>
		<div id="overlayText" class="overlay-text">Caricamento in corso...</div>
    </div>
    
	
<center>Moon ephemeris calculator for photographers<br>
v.0.12.0 - 27/01/2024<br>
</center>
<table border=1>
<tr>
<td style="vertical-align: top;">
<table border = 4>
  <tr>
    <td style="vertical-align: top;">
    <button onclick="clearMap()">Clear map</button><br>
INPUT:<br>
      <table  border= 1>
        <tr>
          <td style="vertical-align: top;">
            Start date:  <input type="text" id="startDate" name="startDate" ><br>
            Hours interval:  <br>
            <input type="radio" id="hourSunrise" name="hourInterval" value="sunrise">
            <label for="hourSunrise">Sunrise</label><br>
            <input type="radio" id="hourSunset" name="hourInterval" value="sunset" checked>
            <label for="hourSunset">Sunset</label><br>
            <input type="radio" id="hourCustom" name="hourInterval" value="custom">
            <label for="hourCustom">Custom</label>:<br>
            From <input type="text" id="startCustomRange" name="startCustomRange" value = "2022-02-05 17:00" ><br>
            To <input type="text" id="endCustomRange" name="endCustomRange" value = "2022-02-05 20:00"><br>

            <table border=1> <!-- Map parameters -->
              <tr>
                  <td>
                      Altitude:
                  </td>
                  <td>
                      From
                  </td>
                  <td>
                      <input type="text" id="minAlt" name="minAlt" value=0 size=3>
                  </td>
                  <td>
                      to
                  </td>
                  <td>
                      <input type="text" id="maxAlt" name="maxAlt" value=10 size=3>
                  </td>
              </tr>

              <tr>
                  <td>
                      Azimuth:
                  </td>
                  <td>
                      From
                  </td>
                  <td>
                      <input type="text" id="minAz" name="minAz" value=0 size=3>
                  </td>
                  <td>
                      to
                  </td>
                  <td>
                      <input type="text" id="maxAz" name="maxAz" value=360 size=3>
                  </td>
              </tr>

              <tr>
                  <td>
                      Moon phase:
                  </td>
                   <td>
                      From
                  </td>
                   <td>
                      <input type="text" id="minPhase" name="minPhase" value=74 size=3>%
                  </td>
                   <td>
                      to
                  </td>
                   <td>
                      <input type="text" id="maxPhase" name="maxPhase" value=100 size=3>%
                  </td>
              </tr>


              <tr>
                  <td>
                  Next days:
                  </td>
                  <td>

                  </td>
                  <td>
                      <input type="text" id="nextDays" name="nextDays" value=30 size=3>
                  </td>
              </tr>

              <tr>
                  <td>
                      Substeps:
                  </td>
                  <td>

                  </td>
                  <td>
                      <input type="text" id="substeps" name="substeps" value=3 size=3><br>
                  </td>
              </tr>
            </table> <!-- End map parameters -->

          </td>

        </tr>
      </table><br>
OUTPUT:<br>
  <table border=1>
    <tr>
      <td style="vertical-align: top;">
        <span id="spnObserverPopup" name = "spnObserverPopup" style="vertical-align: top;">
        </span><br>
        <!-- popup holder -->
        Map center:<br> <span id="spnMapCenter" name="spnMapCenter">xx.xxxx, xx.xxxx</span>
      </td>
      <td  style="vertical-align: top;">
        <span id="spnLinePopup" name = "spnLinePopup"  style="vertical-align: top;">
        -
        </span>
        <!-- popup holder -->
      </td>
    <td>

    </td>
    <tr>
  </table>
      Status: <span id="status" name="status">-</span><br>
    </td> <!-- End input for map-->

    <td style="vertical-align: top;">
      <div id="mapid" style="width: 600px; height: 340px;"></div>
            <div id="cesiumContainer" style="width: 600px; height: 340px;"></div>
<div id="toolbar">
</div>

    </td>

  </tr>

  <tr>


    <td  style="vertical-align: top;"> <!-- Input for Cesium -->
      <table border=1>
      <tr>
        <td  colspan = 2>

        </td>
      </tr>
        <tr>
          <td style="vertical-align: top;">
          <!-- Radioboxes: -->
            <span>
              <input type="radio" id="camera" name="subject" value="camera" checked>
              <label for="camera">camera:</label>
            </span>
            <span id="cameraPos" name="cameraPos">-</span><br>
            <span>
              <input type="radio" id="target" name="subject" value="target">
              <label for="target">target:</label>
            </span>

            <span id="targetPos" name="targetPos">-</span><br>
            Target Elevation: <span id="targetAlt" name="targetAlt">-</span><br>
            Target Azimuth: <span id="targetAz" name="targetAz">-</span><br>
            <button onclick="manualPointing=false;  pointTargetFromCamera(cameraLatitudeDeg, cameraLongitudeDeg, cameraHeight, targetLatitudeDeg, targetLongitudeDeg, targetHeight)" title=" Look at target">PT</button><br>
            <button onclick="" title="Look at direction from specified location">PDL</button><br>
            <button onclick="" title="Look at direction from here">PDH</button><br>
          </td>
          <td>
      <center>
      <table border = 1>
        <tr>
          <td colspan=2><center>Moon</center></td>
        </tr>
       <tr>
          <td>Alt:</td> <td><span id="spnMoonAlt" name ="spnMoonAlt"></span></td>
        </tr>
        <tr>
          <td>Az:</td> <td><span id="spnMoonAz" name ="spnMoonAz"></span></td>
        </tr>
        <tr>
          <td colspan=2><center><br>Camera</center></td>
        </tr>
        <tr>
          <td>Pitch/El/Alt:</td> <td><span id="spnCameraPitchEl" name ="spnCameraPitchEl"></span></td>
        </tr>
        <tr>
          <td>Yaw/Heading/Az:</td> <td><span id="spnCameraYawHeading" name ="spnCameraYawHeading"></span></td>
        </tr>
        <tr>
          <td colspan = 2 style="width:220px"><center><span id="spnCameraLoc" style="width:220px" name ="spnCameraLoc"></span></center>
          </td>
        </tr>
      </table>
      </center>
          </td>
        </tr>
        <tr>
            <td>
              Manual input: <br>
              Origin: <input type="text" value="41.993197, 12.635758, 300" id="flyLocGoogle" name="flyLocGoogle" size="22" ><br>
             Copy from:<button onclick="posFromMap()">Map center</button>
              <button onclick="posFromObserver()">Observer pos</button><br>
              Dest: <button onclick="destFromLine()">Copy from line</button><br>
			  Az: <input type="text" value = "256" id = "flyaz" name="flyaz" size="3"> Alt: <input type="text" value = "0" id = "flyel" name="flyel" size="3"><br>
              Date:  <input type="text" value = "2023-03-13T08:00:00.000Z" id = "resultDate" name="resultDate"> <br>
              <button onclick="gotoLocation()">Fly to</button><br>
            </td>
            <td>
            Locations:<br>
            <span id = "spnLocations" name="spnLocations"></span>
            </td>
        </tr>
      </table>


    </td>
    <td>
      <table border = 1>
        <tr>
          <td>
         </td>
          <td>
            <table border =0>
              <tr>
                <td>
                Height:<span id="spnCameraHeight" name="spnCameraHeight">200</span>
                </td>
              </tr>
              <tr>
                <td>
                <button onclick="heightPlus()">+</button>
                </td>
              </tr>
              <tr>
                <td>
                  <input style="vertical-align: bottom;"type="range" orient="vertical" step="10" value = "200" id = "rngHeight" name = "rngHeight" min = "1" max  = "1000" onChange="changeHeight()">
                </td>
              </tr>
              <tr>
                <td>
                <button onclick="heightMinus()">-</button>
                </td>
              </tr>
            </table>
          </td>
          <td>
            <table border = 0>
              <tr>
                <td>
                Zoom: <span id="spnCameraZoom" name="spnCameraZoom">50</span>
                </td>
              </tr>
              <tr>
                <td>
                <button onclick="zoomIn()">+</button>
                </td>
              </tr>
              <tr>
                <td>
                <input style="vertical-align: bottom;"type="range" orient="vertical" step="1" value = "50" id = "rngZoom" name = "rngZoom" min = "1" max  = "89" onChange="changeZoom()">
                </td>
              </tr>
              <tr>
                <td>
                <button onclick="zoomOut()">-</button>
                </td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
      <table border=1>
        <tr>
          <td>
            <button onclick="lookUp()">^</button>
            <button onclick="lookDown()">v</button>
            <button onclick="northUp()">N</button>
            <button onclick="lookAtMoon()">Moon</button>
            <button onclick="lookAtSun()">Sun</button>
          </td>
        </tr>
        <tr>
          <td>
          <input type="checkbox" id = "chkGPS" name = "chkGPS"> GPS
          <input type="checkbox" id = "chkSync2D" name = "chkSync2D"> Sync from 2D
          <input type="checkbox" id = "chkTrack" name = "chkTrack"> Track
          <input type="checkbox" id = "chkLockH" name = "chkLockH"> Lock height
          <input type="text" id = "lockedHeight" name="lockedHeight" size=4 value = 200>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <button onclick = "resetRoll()">Reset roll</button>
            <button onclick = "setMoonSun3dLines()">Update lines</button>
          </td>
        </tr>
      </table>
      Camera controls:<br>
       - Rotate: SHIFT + LEFTMOUSE<br>
       - Move: WASD + PE<br>
      Rotate world: CTRL + LEFTMOUSE<br>
    </td>
  </tr>
        <tr>

        </tr>
</table>
    </td>
    <td style="vertical-align: top;">
    <table>
      <tr>
        <td rowspan=2 style="vertical-align: top;">
          <table id="tblResults" name="tblResults" border =0>
          </table>
        </td>
      </tr>
    </table>
    </td>
  </tr>
</table>
<br>
Observing location:<br>
<span id="observingLocation1" name="observingLocation1">-</span><br>
<span id="observingLocation2" name="observingLocation2">-</span><br>

Tune parameters, then click on map to see moon visibility directions.<br>
<br>
Use <a href="http://xjubier.free.fr/en/site_pages/astronomy/MoonExposureCalculator.html">this site</a> to calculate best exposure data to take photos of the moon.<br>
Time check:<br>
<a href="https://www.mooncalc.org/#/41.9969,12.8408,3/2023.10.02/08:48/1/3">Mooncalc.org</a><br>
<a href="https://www.suncalc.org/#/40.1789,-3.5156,3/2023.10.02/08:48/1/3">Suncalc.org</a><br>
<a href="http://suncalc.net/#/51.508,-0.125,2/2023.10.02/08:48">Suncalc.net</a><br>
Moon data:<br>
<a href="http://moon.owghat.com/">http://moon.owghat.com/</a><br>
<br>
  <script src="utilsLC.js"></script> <!-- Basic drawing functions -->
  <script src="basicLC.js"></script> <!-- Cesium viewer setup - to be placed AFTER body, else it will not find Cesium DIV container-->
  <script src="suncalc-new.js"></script> <!-- Mia versione modificata-->


<script>

////////////// Cesium management
var targetLatRad;
var targetLonRad;
var targetLatDeg;
var targetLonDeg;
var targetHeight;
var targetAvailable;
var cameraLongitudeDeg;
var cameraLatitudeDeg;
var cameraLongitudeRad;
var cameraLatitudeRad;
var cameraHeight;
var cameraAvailable;
var ellipsoid = Cesium.Ellipsoid.WGS84;
var cameraControlsEnabled = false;
var currTime = new Date().getTime();
var baseTime = new Date().getTime();
var prevLine;
var eventEnabled = false;
selectedLine = -1;
bufLineTarget = null;
bufMarkerObserver = null;
myLines = [];
mymap = null;
markerLayer = null;
moonLine = null;
oldHeight =0;
manuallySetHeight = false;
locationHeightAvailble = false;

const LINE_LENGTH_KM = 100;
const RECT_WIDTH  = 0.002;
const RECT_HEIGHT = 0.001;
const STEP_SECONDS = 600;
const CAMERA_PITCH_CORRECTION_RAD = 2 * Cesium.Math.PI/180;
const CAMERA_HEADING_CORRECTION_RAD = 2.70 * Cesium.Math.PI/180;
const DEFAULT_LINE_COLOR = "#8888AA";
const HIGHLIGHT_LINE_COLOR = "#55AA55";
const SELECTED_LINE_COLOR = "#5555AA";
const MOON_LINE_COLOR = "#333333";
const TYPE_LOOK = 1;
const TYPE_GOTO = 2;
const LOC_MOON = -1;
const LOC_SUN = -2;

pointedLocation = LOC_MOON;
firstRun = true;

scene = viewer.scene;

scene.globe.tileLoadProgressEvent.addEventListener(function(a) {
  // Il terreno predefinito è completamente caricato
  console.log("Loading....",a);
  document.getElementById("overlayText").innerHTML = "Caricamento in corso... " + a;
  if (scene.globe.tilesLoaded) {
  	//alert("READY!");
   
	  const overlay = document.getElementById('overlay');
  overlay.style.display = 'none';
  changeHeight();
  
  

      
 }
});






////// // Imposta ora locale in Cesium
viewer.animation.viewModel.timeFormatter = function(date, viewModel) {
	dateTime=new Date(date);
	var localTime =  dateTime.getHours().toString().padStart(2, '0') + ":" + dateTime.getMinutes().toString().padStart(2, '0')  + ":" + dateTime.getSeconds().toString().padStart(2, '0');  
	return localTime;//dateTime.toLocaleString();
};

viewer.animation.viewModel.dateFormatter = function(date, viewModel) {
	dateTime=new Date(date);
	var localTime = dateTime.getFullYear() + "/" + (dateTime.getMonth()+1).toString().padStart(2, '0') + "/" + dateTime.getDate().toString().padStart(2, '0');
	return localTime;//dateTime.toLocaleString();
};

///////////


CesiumCamera = new Cesium.Camera(scene);
targetAvailable = false;
cameraAvailable = false;
var startMousePosition;
var mousePosition;
compassCtx = null;

var flags = {
  looking: false,
  moveForward: false,   // W
  moveBackward: false,  // S
  moveUp: false,        // Q
  moveDown: false,      // E
  moveLeft: false,      // A
  moveRight: false,     // D
};


setupCesiumCompass();

function setupCesiumCompass() {
  canvas2d = document.createElement("canvas");
  canvas2d.style.position = 'relative';

  cesiumContainer.appendChild(canvas2d);
  cesiumCanvasCenterX = viewer.canvas.width/2;
  cesiumCanvasCenterY = viewer.canvas.height/2;
  compassCtx = canvas2d.getContext("2d");

    canvas2d.width = 100; // Compass image dimensions
    canvas2d.height = 100;
    //canvas2d.style.top = -viewer.canvas.height + "px";
    //canvas2d.style.left = 0;


  compassImage = new Image();
  compassImage.onload = function () {
    compassImage.width = compassImage.width/2;
    compassImage.height = compassImage.height/2;
    canvas2d.width = compassImage.width; // Compass image dimensions
    canvas2d.height = compassImage.height;
    canvas2d.style = "position:relative;top:-"  + (viewer.canvas.height / 2 + compassImage.height/2)  + "px;left:"  + (viewer.canvas.width / 2 - compassImage.width/2)  +"px;"
  };
  compassImage.src = 'compass.png';
}





function setCompassRotation(ang) {
    compassCtx.save()
    compassCtx.clearRect(0, 0, compassCtx.canvas.width, compassCtx.canvas.height); //clear the canvas
    var pos = {x: compassCtx.canvas.width/2, y: compassCtx.canvas.height/2}
    compassCtx.translate(pos.x ,pos.y)
    compassCtx.rotate(Math.PI / 180 * ang)
    compassCtx.drawImage(compassImage, -compassImage.width / 2, -compassImage.height / 2, compassImage.width, compassImage.height)
    compassCtx.restore()
}


/////


function posFromMap() {
  var pos =  mymap.getCenter();
  inputLon = pos.lng * 1.0;
  inputLat = pos.lat * 1.0;
  var cartographic = Cesium.Cartographic.fromDegrees(  inputLon, inputLat, 5000, new Cesium.Cartographic());
  var positions = [ cartographic ];
  var promise = Cesium.sampleTerrain(viewer.terrainProvider, 11, positions);
  Cesium.when(promise, function( updatedPositions ) {
    height = updatedPositions[0].height;
    flyLocGoogle.value = inputLat.toFixed(6) + "," + inputLon.toFixed(6) + "," + (height+100).toFixed(0);
  });
}



function  posFromObserver() {
  if (bufMarkerObserver !== null) {
    inputLon = bufMarkerObserver.lng * 1.0;
    inputLat = bufMarkerObserver.lat * 1.0;
    var cartographic = Cesium.Cartographic.fromDegrees(  inputLon, inputLat, 5000, new Cesium.Cartographic());
    var positions = [ cartographic ];
    promiseObserverHeight = Cesium.sampleTerrain(viewer.terrainProvider, 11, positions);
    Cesium.when(promiseObserverHeight, function( updatedPositions ) {
      height = updatedPositions[0].height;
      flyLocGoogle.value = inputLat.toFixed(6) + "," + inputLon.toFixed(6) + "," + (height+100).toFixed(0);
    });
} else {
    alert("Please select an observer position on 2d map");
  }
}



function destFromLine() {
console.log("destFromLine: bufLineTarget=",bufLineTarget)
    if (bufLineTarget !== null) {
      flyaz.value = bufLineTarget.moonAz;
      flyel.value = bufLineTarget.moonAlt;
      var a = new Date(bufLineTarget.time);
      var UTCtime = a.getUTCFullYear() + "-" + (a.getUTCMonth()+1) + "-" + a.getUTCDate() + " " + a.getUTCHours() + ":" + a.getUTCMinutes() + ":" + a.getUTCSeconds()
      resultDate.value = UTCtime;	  
    } else {
        alert ("Please select a direction on the map or a line on the table.");
    }
}




function openMoonCalc(lin) {
console.log("openMoonCalc for line ", lin , ":  bufLineTarget=",bufLineTarget);
console.log("openMoonCalc:  , myLines[lin]=", myLines[lin]);
	// https://www.mooncalc.org/#/LAT,LON,ZOOM/YYYY.MM.DD/hh:mm/HEIGTH/MAP_STYLE ; hour in local time, not GMT
		var a = new Date(myLines[lin].options.myTime);
		var moonCalcDate = a.getFullYear() + "." + (a.getMonth()+1).toString().padStart(2, '0') + "." + a.getDate().toString().padStart(2, '0') + "/" + a.getHours().toString().padStart(2, '0') + ":" + a.getMinutes().toString().padStart(2, '0') + "/1/3";
		var moonCalcLocation = myLines[lin].options.mySource.lat.toFixed(6) + "," + myLines[lin].options.mySource.lng.toFixed(6) + ",115"; 
		var moonCalcUrl =  "https://www.mooncalc.org/#/" + moonCalcLocation + "/" +  moonCalcDate;
console.log(moonCalcDate, moonCalcUrl);		
		window.open(moonCalcUrl, "_blank");
}



function clickOnF(lin) {
console.log("Elaboro click su F in linea ", lin);
	highlightLinePermanently(lin);
	posFromObserver();
console.log("CLICKF line :",myLines[lin].options.myTime);	
	var localDate = new Date(myLines[lin].options.myTime);
console.log("CLICKF localDate:",localDate);	
	var myDate = localDate.getFullYear() + "/" +  (localDate.getMonth()+1).toString().padStart(2, '0') + "/" +  localDate.getDate().toString().padStart(2, '0') + " " + localDate.getHours().toString().padStart(2, '0') + ":" + localDate.getMinutes().toString().padStart(2, '0');
console.log("CLICKF myDate:",myLines[lin].options.myAz,  myLines[lin].options.myAlt, myDate);	
	destFromTableRow( myLines[lin].options.myAz,  myLines[lin].options.myAlt, myDate);
	gotoLocation();
}

function destFromTableRow(az,el, UTCtime) {
      flyaz.value = az;
      flyel.value = el;
      resultDate.value = UTCtime;
}



function updateTooltips() {
    var edges = getMapEdges(mymap,false);
    CORRECTX = (mymap.getBounds().getEast() - mymap.getBounds().getWest())/50;
    CORRECTY = (mymap.getBounds().getNorth() - mymap.getBounds().getSouth())/50;
    if (typeof (myLocationLine) !== "undefined") {
      for (var locnum = 0; locnum < myLocationLine.length; locnum++) {
        var inters1 = intersect(edges.top,    myLocationLine[locnum], false, mymap, myLocations[locnum].name + "N"); inters1.lat -=  CORRECTY;
        var inters2 = intersect(edges.right,  myLocationLine[locnum], false, mymap, myLocations[locnum].name + "E"); inters2.lng -=  CORRECTX;
        var inters3 = intersect(edges.bottom, myLocationLine[locnum], false, mymap, myLocations[locnum].name + "S"); inters3.lat +=  CORRECTY;
        var inters4 = intersect(edges.left,   myLocationLine[locnum], false, mymap, myLocations[locnum].name + "W"); inters4.lng +=  CORRECTX

        if (inters1.inters)  {
          myLocationEdgeTooltips[locnum*4].setLatLng(inters1);
          mymap.openTooltip(myLocationEdgeTooltips[locnum*4]);
          myLocationEdgeTooltips[locnum*4+0.0].setOpacity(0.5);
        } else {
          mymap.closeTooltip(myLocationEdgeTooltips[locnum*4]);
        }

        if (inters2.inters)  {
          myLocationEdgeTooltips[locnum*4+1.0].setLatLng(inters2);
          mymap.openTooltip(myLocationEdgeTooltips[locnum*4+1.0]);
          myLocationEdgeTooltips[locnum*4+1.0].setOpacity(0.5);
        } else {
          mymap.closeTooltip(myLocationEdgeTooltips[locnum*4+1.0]);
        }

        if (inters3.inters)  {
          myLocationEdgeTooltips[locnum*4+2.0].setLatLng(inters3);
          mymap.openTooltip(myLocationEdgeTooltips[locnum*4+2.0]);
          myLocationEdgeTooltips[locnum*4+2.0].setOpacity(0.5);
        } else {
          mymap.closeTooltip(myLocationEdgeTooltips[locnum*4+2.0]);
        }

        if (inters4.inters)  {
          myLocationEdgeTooltips[locnum*4+3.0].setLatLng(inters4);
          mymap.openTooltip(myLocationEdgeTooltips[locnum*4+3.0]);
          myLocationEdgeTooltips[locnum*4+3.0].setOpacity(0.5);
        } else {
          mymap.closeTooltip(myLocationEdgeTooltips[locnum*4+3.0]);
        }

        // If no intersection exists between line and edges, then location is visible: turn on only one tooltip, without NEWS indication (all the others are already closed):
        if ((!inters1.inters) && (!inters2.inters) && (!inters3.inters) && (!inters4.inters)) {
          myLocationEdgeTooltips[locnum*4].setLatLng({lng: myLocations[locnum].lng , lat: myLocations[locnum].lat});
          myLocationEdgeTooltips[locnum*4].setContent(myLocations[locnum].name);
          myLocationEdgeTooltips[locnum*4].setOpacity(1);
          mymap.openTooltip(myLocationEdgeTooltips[locnum*4]);
        }
      }
    }
}


function onMapDrag(e){
    var pos =  mymap.getCenter();
    updateLocationLines();
    updateCameraLine();
    if (chkSync2D.checked) {
      syncCesium();
    }
    updateTooltips();
}



function syncCesium() {
  ////// Sync from 2d to 3d
  storeFOV = viewer.camera.frustum.fov;
  storeHeading = viewer.camera.heading;
  storePitch = viewer.camera.pitch;
  if (manuallySetHeight) {
    storeHeight = rngHeight.value *1.0;
    manuallySetHeight = false;
  } else {
    storeHeight = Cesium.Cartographic.fromCartesian(viewer.camera.position).height;
  }

  var pos =  mymap.getCenter();
  inputLon = pos.lng;
  inputLat = pos.lat;
  flyLocGoogle.value = inputLat.toFixed(6) + "," + inputLon.toFixed(6) + "," + storeHeight.toFixed(0);
  viewer.camera.flyTo({
      destination: Cesium.Cartesian3.fromDegrees(inputLon, inputLat, storeHeight),
      orientation: {
        heading: storeHeading,
        pitch: storePitch,
        roll: 0.0,
      },
      duration : 0
  });
  viewer.camera.frustum.fov = storeFOV;

  updateLocationLines();
  updateCameraLine();
  updateLookDirection();

}



function syncMap() {
////// Sync from 3d to 2d
  var storeMapZoom = mymap.getZoom()
  inputLon = viewer.camera.positionCartographic.longitude*180/Cesium.Math.PI;
  inputLat = viewer.camera.positionCartographic.latitude*180/Cesium.Math.PI;
  mymap.setView([inputLat, inputLon], storeMapZoom); // preserve previous zoom level while syncing to 3d view
}


/*
        heading: moonDataMeeus.moonAzimuthRad + Math.PI,
        pitch: moonDataMeeus.moonAltitudeRefractionRad,
        */

function findMoon(dateJS, lat, lon, debug) {
///// Calculate Elevation and Azimuth of Moon as seen from given position
//  var moonData = SunCalc.getMoonPosition(dateJS, lat,  lon);
      moonData = mooncalcMeeus(dateJS, lat, lon, 0);
//      moonPhase = moonData.moonIllumFractionDetailPercentage; // Debug: serve qui?
		  
	
/////////////

/*var obs = new Astronomy.Observer(parseFloat(lat), parseFloat(lon) ,  100);  
var moonRD = Astronomy.Equator(Astronomy.Body.Moon, dateJS, obs, true, true); 
var moonAltAzAstro = Astronomy.Horizon(dateJS, obs , moonRD.ra, moonRD.dec, false) 
*/
////////////
		  
      if (debug) {
       console.log(moonData.moonAzimuthDegrees,  moonData.moonAltitudeRefractionDegrees );
console.log("FINDMOON",dateJS, lat, parseFloat(lat), lon, debug)
      }

        return (
          {
            altRad:  moonData.moonAltitudeRefractionRad,
            azRad:   moonData.moonAzimuthRad,
            altDeg : moonData.moonAltitudeRefractionDegrees,
            azDeg : moonData.moonAzimuthDegrees
          }
/*
        return (
          {
            altRad:  moonAltAzAstro.altitude, //moonData.moonAltitudeRefractionRad,
            azRad:   moonAltAzAstro.azimuth, // moonData.moonAzimuthRad,
            altDeg : moonAltAzAstro.altitude * 180 / Math.PI, //moonData.moonAltitudeRefractionDegrees,
            azDeg :  moonAltAzAstro.azimuth * 180 / Math.PI //moonData.moonAzimuthDegrees
          }*/

        );
      }


/////////  moon cesium tests ///////////

    function findMoonCesium(dateJS, lat, lon) {
        var pointA = new Cesium.Cartesian3.fromDegrees(lon, lat,  0);
        var pointB = Cesium.Simon1994PlanetaryPositions.computeMoonPositionInEarthInertialFrame(Cesium.JulianDate.fromDate(dateJS));

        const transform=Cesium.Transforms.eastNorthUpToFixedFrame(pointA);
        const positionvector=Cesium.Cartesian3.subtract(pointB,pointA,new Cesium.Cartesian3());
        const vector=Cesium.Matrix4.multiplyByPointAsVector(Cesium.Matrix4.inverse(transform,new Cesium.Matrix4()),positionvector,new Cesium.Cartesian3());
        const direction=Cesium.Cartesian3.normalize(vector,new Cesium.Cartesian3());

        //heading
        const headingRadRaw = Math.atan2(direction.y, direction.x) - Cesium.Math.PI_OVER_TWO;
        const headingRadFixed = Cesium.Math.PI - Cesium.Math.zeroToTwoPi(headingRadRaw);
        const headingDegFixed = Cesium.Math.toDegrees(Cesium.Math.PI - Cesium.Math.zeroToTwoPi(headingRadFixed));

        //pitch
        const pitchRad = Cesium.Math.PI_OVER_TWO - Cesium.Math.acosClamped(direction.z);
        const pitchDeg = Cesium.Math.toDegrees(Cesium.Math.PI_OVER_TWO - Cesium.Math.acosClamped(direction.z));

        if ((headingDegFixed<0)) {
          headingDegFixed2 = - headingDegFixed;
        } else {
          headingDegFixed2 = 360 - headingDegFixed;
        }

      return (
        {
          altRad: pitchRad,
          azRad: headingDegFixed2 * Math.PI/180,
          altDeg : pitchRad * 180 / Cesium.Math.PI,
          azDeg : headingDegFixed2
        }
      );
    }



    function lookAtMoonCesium(camera, dateJS, lat, lng) {
      const icrfToFixed = new Cesium.Matrix3();
      var dateCesium = Cesium.JulianDate.fromDate(dateJS);
      if (!(Cesium.Transforms.computeIcrfToFixedMatrix(dateCesium, icrfToFixed))) {
        Cesium.Transforms.computeTemeToPseudoFixedMatrix(dateCesium, icrfToFixed);
      }
      moonPosition = getCesiumMoonCartesian3(dateJS);
      Cesium.Matrix3.multiplyByVector(icrfToFixed, moonPosition, moonPosition);
      myObserver = new Cesium.Cartesian3.fromDegrees(lng, lat,  0);
      myPositionvector=Cesium.Cartesian3.subtract(myObserver, moonPosition, new Cesium.Cartesian3());
      viewer.camera.flyTo({
          destination: viewer.camera.position,
          orientation: myPositionvector,
      });
      /*viewer.camera.viewBoundingSphere(
        new Cesium.BoundingSphere(moonPosition,  100000000)
      );*/
    }



    function getCesiumMoonCartesian3(dateJS) {
      var dateCesium = Cesium.JulianDate.fromDate(dateJS);
      const icrfToFixed = new Cesium.Matrix3();
      if (!(Cesium.Transforms.computeIcrfToFixedMatrix(dateCesium, icrfToFixed))) {
        Cesium.Transforms.computeTemeToPseudoFixedMatrix(dateCesium, icrfToFixed);
      }
      moonPosition = Cesium.Simon1994PlanetaryPositions.computeMoonPositionInEarthInertialFrame(dateCesium);
      return moonPosition;
    }

/////////


function lookAtMoonOld() {
  var now = Cesium.JulianDate.toDate(viewer.clock.currentTime);
  var nowJS = new Date(now)
  var tempLat = viewer.camera.positionCartographic.latitude  * 180 / Cesium.Math.PI;
  var tempLon = viewer.camera.positionCartographic.longitude * 180 / Cesium.Math.PI;
  var moonData = findMoon(nowJS, tempLat, tempLon);
  storeFOV = viewer.camera.frustum.fov;
  viewer.camera.flyTo({
      destination: viewer.camera.position,
      orientation: {
        heading: moonData.azRad,
        pitch: moonData.altRad,
        roll: 0.0,
      },
  });
  viewer.camera.frustum.fov = storeFOV;
}



function lookAtMoonOrgOld() {
//  var now = viewer.clock.currentTime.toString();
  var nowJS = new Date(Cesium.JulianDate.toDate(viewer.clock.currentTime))
  var tempLat = viewer.camera.positionCartographic.latitude  * 180 / Cesium.Math.PI;
  var tempLon = viewer.camera.positionCartographic.longitude * 180 / Cesium.Math.PI;
  //moonData =  mymooncalc(nowJS, tempLat, tempLon, 0, 1);
  moonData = mooncalcMeeus(nowJS, tempLat, tempLon, 0);
console.log(nowJS, "Pointing to alt,az = ",  moonData.moonAltitudeRefractionDegrees, moonData.moonAzimuthDegrees);
  storeFOV = viewer.camera.frustum.fov;
  viewer.camera.flyTo({
      destination: viewer.camera.position,
      orientation: {
        heading: moonData.moonAzimuthDegrees * 3.14/180,
        pitch: moonData.moonAltitudeRefractionDegrees * 3.14/180,
        roll: 0.0,
      },
  });
  viewer.camera.frustum.fov = storeFOV;
}


function lookAtMoon() {
  //var now = viewer.clock.currentTime.toString();
  var nowJS = new Date(Cesium.JulianDate.toDate(viewer.clock.currentTime))
  var tempLat = viewer.camera.positionCartographic.latitude  * 180 / Cesium.Math.PI;
  var tempLon = viewer.camera.positionCartographic.longitude * 180 / Cesium.Math.PI;
  moonDataMeeus = mooncalcMeeus(nowJS, tempLat, tempLon, 0);
//console.log(nowJS, "Pointing to alt,az = ",  moonDataMeeus.moonAltitudeRefractionDegrees, moonDataMeeus.moonAzimuthDegrees,moonDataMeeus.moonAzimuthDegrees+180);
  storeFOV = viewer.camera.frustum.fov;
  viewer.camera.setView({ // debug flyto
      destination: viewer.camera.position,
      orientation: {
        heading: moonDataMeeus.moonAzimuthRad,
        pitch: moonDataMeeus.moonAltitudeRefractionRad,
        roll: 0.0,
      },
  });
  viewer.camera.frustum.fov = storeFOV;
}



function lookAtSun() {
  //var now = viewer.clock.currentTime.toString();
  var nowJS = new Date(Cesium.JulianDate.toDate(viewer.clock.currentTime))
  var tempLat = viewer.camera.positionCartographic.latitude  * 180 / Cesium.Math.PI;
  var tempLon = viewer.camera.positionCartographic.longitude * 180 / Cesium.Math.PI;
  sunDataMeeus = suncalcMeeus(nowJS, tempLat, tempLon, 0);

  storeFOV = viewer.camera.frustum.fov;
  viewer.camera.setView({
      destination: viewer.camera.position,
      orientation: {
        heading: sunDataMeeus.sunAzimuthRad,
        pitch: sunDataMeeus.sunAltitudeRad,
        roll: 0.0,
      },
  });
  viewer.camera.frustum.fov = storeFOV;
}


function lookAt(locnum, type) { // type = 1 LOOK, =2 GOTO
var cartographic;
var positions;
  if (locnum < 0) {
    // track moon or sun (debug: to do)
    return;
  }
console.log("locnum=",locnum, myLocations[locnum]);

  if (chkLockH.checked) {  // observer height locked: use it, then check if location height is needed
    observerHeight = lockedHeight.value * 1.0;

      if(!chkTrack.checked) { // if tracking is not active, query also for location height
console.log("Not tracking, query location height...");
        var cartographic2 = Cesium.Cartographic.fromDegrees( myLocations[locnum].lng, myLocations[locnum].lat, 5000, new Cesium.Cartographic());
        var positions2 = [ cartographic2 ];
        var promiseLoc = Cesium.sampleTerrain(viewer.terrainProvider, 11, positions2);
        Cesium.when(promiseLoc, function( updatedPositions2 ) {
          locationHeight = updatedPositions2[0].height;
console.log("Location height 1 received.",locationHeight);
          // All data available: point camera:
console.log("Not tracking", type, observerHeight, locationHeight)
        internalLookAt(type, observerHeight, locationHeight, locnum)
        });
      } else { // if tracking is active, location height could have been already queried
console.log("Tracking...");
        if (!locationHeightAvailble) { // if location height has not yet been queried, query for it
console.log("Height not avail, querying...");
          var cartographic3 = Cesium.Cartographic.fromDegrees( myLocations[locnum].lng, myLocations[locnum].lat, 5000, new Cesium.Cartographic());
          var positions3 = [ cartographic3 ];
          var promiseLoc2 = Cesium.sampleTerrain(viewer.terrainProvider, 11, positions3);
          Cesium.when(promiseLoc2, function( updatedPositions3 ) {
            locationHeight = updatedPositions3[0].height;
console.log("Location height 2 received.",observerHeight, locationHeight);
            locationHeightAvailble = true; // at end of promise
console.log("Pointing camera...",type, observerHeight, locationHeight);
        console.log(type, observerHeight, locationHeight)
        internalLookAt(type, observerHeight, locationHeight, locnum)

      });
        } else { // locationHeightAvailble
console.log("Height already avail, pointing and done.");
console.log("Pointing camera...",type, observerHeight, locationHeight);
        console.log(type, observerHeight, locationHeight)
        internalLookAt(type, observerHeight, locationHeight, locnum)

      } // locationHeightAvailble
    } // if tracking is active

  } else { // if observer height is not locked, query for it,  then, if needed, also location height:
    ///// query observer height
    cartographic = Cesium.Cartographic.fromDegrees( mymap.getCenter().lng, mymap.getCenter().lat, 5000, new Cesium.Cartographic());
    positions = [ cartographic ];
    var promiseObs = Cesium.sampleTerrain(viewer.terrainProvider, 11, positions);
console.log("Querying height for observer...");
    Cesium.when(promiseObs, function( updatedPositions ) {
      observerHeight = updatedPositions[0].height;
console.log("Observer height received.",observerHeight);
      if(!chkTrack.checked) { // if tracking is not active, query also for location height
console.log("Not tracking, query location height...");
        var cartographic2 = Cesium.Cartographic.fromDegrees( myLocations[locnum].lng, myLocations[locnum].lat, 5000, new Cesium.Cartographic());
        var positions2 = [ cartographic2 ];
        var promiseLoc = Cesium.sampleTerrain(viewer.terrainProvider, 11, positions2);
        Cesium.when(promiseLoc, function( updatedPositions2 ) {
          locationHeight = updatedPositions2[0].height;
console.log("Location height 1 received.",locationHeight);
          // All data available: point camera:
        console.log(type, observerHeight, locationHeight)
        internalLookAt(type, observerHeight, locationHeight, locnum)
        });
      } else { // if tracking is active, location height could have been already queried
console.log("Tracking...");
        if (!locationHeightAvailble) { // if location height has not yet been queried, query for it
console.log("Height not avail, querying...");
          var cartographic3 = Cesium.Cartographic.fromDegrees( myLocations[locnum].lng, myLocations[locnum].lat, 5000, new Cesium.Cartographic());
          var positions3 = [ cartographic3 ];
          var promiseLoc2 = Cesium.sampleTerrain(viewer.terrainProvider, 11, positions3);
          Cesium.when(promiseLoc2, function( updatedPositions3 ) {
            locationHeight = updatedPositions3[0].height;
console.log("Location height 2 received.",observerHeight, locationHeight);
            locationHeightAvailble = true; // at end of promise
console.log("Pointing camera...",type, observerHeight, locationHeight);
        console.log(type, observerHeight, locationHeight)
        internalLookAt(type, observerHeight, locationHeight, locnum)

      });
        } else { // locationHeightAvailble
console.log("Height already avail, pointing and done.");
console.log("Pointing camera...",type, observerHeight, locationHeight);
        console.log(type, observerHeight, locationHeight)
        internalLookAt(type, observerHeight, locationHeight, locnum)

      } // locationHeightAvailble
      } // if tracking is active
    });

  }
}


function internalLookAt(type, observerHeight, locationHeight,locnum) {
console.log("Pointing camera...",type, observerHeight, locationHeight);
      // Both heights for observer and location are available; build both objects and use them to ask for Altitude and Azimuth of location w.r.t observer:
      var observerPos = {lat:  mymap.getCenter().lat, lng: mymap.getCenter().lng , height : observerHeight};
      var locationPos = {lat: myLocations[locnum].lat, lng: myLocations[locnum].lng , height : locationHeight};

      // Now that all data are available, calculate pointing data:
      var locationDir = getAltAz(observerPos, locationPos);
      var locationAlt = locationDir.pitchDeg;
      var locationAz = locationDir.headingDeg;

console.log("Look at " ,locationAlt , locationAz);

      // Point camera in that direction:
      var storeFOV = viewer.camera.frustum.fov;
      if (type === TYPE_LOOK) { // look at
      viewer.camera.setView({
          destination: Cesium.Cartesian3.fromDegrees(  mymap.getCenter().lng , mymap.getCenter().lat, observerHeight), // Go to observer position,....
          orientation: { // ... and look at location
            heading: locationAz * 3.14/180,
            pitch: locationAlt * 3.14/180,
            roll: 0.0,
          },
      });
      }

      if (type === TYPE_GOTO) { // go to
        viewer.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees( myLocations[locnum].lng,  myLocations[locnum].lat, locationHeight), // Go to location position,....
            orientation: { // ... and keep viewing direction unchanged.
              heading: viewer.camera.heading,
              pitch: viewer.camera.pitch,
              roll: 0.0,
            },
        });
      }
      viewer.camera.frustum.fov = storeFOV;
}



function gotoLocation() {
  storeFOV = viewer.camera.frustum.fov;
  inputData = document.getElementById("flyLocGoogle").value;
  inputArray = inputData.split(",");
  inputLat = inputArray[0]*1.0;
  inputLon = inputArray[1]*1.0;
  inputAlt = inputArray[2]*1.0;
  inputAz = document.getElementById("flyaz").value *1.0;
  inputPitch = document.getElementById("flyel").value *1.0;
changeHeight();
    
      viewer.camera.setView({  // debug flyto

      destination: Cesium.Cartesian3.fromDegrees(inputLon, inputLat, inputAlt),
      orientation: {
        heading: Cesium.Math.toRadians(inputAz),
        pitch: Cesium.Math.toRadians(inputPitch),
        roll: 0.0,
     },
  });
  viewer.camera.frustum.fov = storeFOV;


  var currentTime = Cesium.JulianDate.fromDate(new Date(document.getElementById("resultDate").value));
  var endTime = Cesium.JulianDate.addDays(currentTime, 1, new Cesium.JulianDate());
console.log("AUTOCHECK:", inputLon, inputLat, inputAlt, inputAz, inputPitch, storeFOV,  currentTime, endTime)  ;

  viewer.clock.currentTime = currentTime;
  viewer.timeline.zoomTo(currentTime, endTime);

  changeZoom();
}






function zoomIn() {
  if (rngZoom.value*1 + 5.0 < rngZoom.max ) {
    rngZoom.value  = rngZoom.value*1 + 5.0 ;
    changeZoom();
  }
}




function zoomOut() {
  if (rngZoom.value*1 -5.0 > rngZoom.min) {
    rngZoom.value  = rngZoom.value*1 - 5.0 ;
    changeZoom();
  }
}




function changeZoom() {
  inputFOV = 90 - rngZoom.value;
  viewer.camera.frustum.fov = Cesium.Math.toRadians(inputFOV);
	document.getElementById("spnCameraZoom").innerHTML = rngZoom.value;
}


function heightPlus() {
  setCameraHeight(moveRate);
}



function heightMinus() {
setCameraHeight(-moveRate);
}


function changeHeight() {
  var deltaHeight = rngHeight.value * 1.0 - oldHeight;
  setCameraHeight(deltaHeight);
}

function resetRoll() {
  viewer.camera.flyTo({
        destination: viewer.camera.position,
        orientation: {
          heading: viewer.camera.heading,
          pitch: viewer.camera.pitch,
          roll: 0.0,
        },
        duration : 0
    });
}

function setCameraHeight (deltaHeight) {
  d = cameraUpDirection(deltaHeight);
  viewer.camera.flyTo({
        destination: d.upPos,
        orientation: {
          heading: viewer.camera.heading,
          pitch: viewer.camera.pitch,
          roll: 0.0,
        },
        duration : 0
    });
	document.getElementById("spnCameraHeight").innerHTML = cameraCartographic.height;
}


function lookDown() {
  CesiumCamera.flyTo({
      destination: viewer.camera.position,
      orientation: {
        heading: viewer.camera.heading,
        pitch: Cesium.Math.toRadians(-90.0),
        roll: 0.0,
      },
  });
}


function lookUp() {
  storeFOV = viewer.camera.frustum.fov;
  CesiumCamera.flyTo({
      destination: viewer.camera.position,
      orientation: {
        heading: viewer.camera.heading,
        pitch: Cesium.Math.toRadians(0.0),
        roll: 0.0,
      },
  });
  viewer.camera.frustum.fov = storeFOV;
}


function northUp() {
  storeFOV = viewer.camera.frustum.fov;
  CesiumCamera.flyTo({
      destination: viewer.camera.position,
      orientation: {
        heading: Cesium.Math.toRadians(0.0),
        pitch: viewer.camera.pitch,
        roll: 0.0,
      },
  });
  viewer.camera.frustum.fov = storeFOV;
}



//////////// CESIUM MOUSE MANAGEMENT //////////////

var handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);

handler.setInputAction(function (event) {
  var pickedPosition = viewer.scene.pickPosition(event.position);
  if (Cesium.defined(pickedPosition)) {
    getMousePosition(pickedPosition);
  }
}, Cesium.ScreenSpaceEventType.LEFT_CLICK);


handler.setInputAction(function (movement) {
  mousePosition = movement.endPosition;
}, Cesium.ScreenSpaceEventType.MOUSE_MOVE);


handler.setInputAction(function (position) {
  flags.looking = false;
}, Cesium.ScreenSpaceEventType.LEFT_UP);
///////////////////////////////////////////////


//////////////// CESIUM KEYBOARD MANAGEMENT ////////////////

  function getFlagForKeyCode(keyCode) {
    switch (keyCode) {
      case "W".charCodeAt(0):
        return "moveForward";
      case "S".charCodeAt(0):
        return "moveBackward";
      case "Q".charCodeAt(0):
        return "moveUp";
      case "E".charCodeAt(0):
        return "moveDown";
      case "D".charCodeAt(0):
        return "moveRight";
      case "A".charCodeAt(0):
        return "moveLeft";
      default:
        return undefined;
    }
  }

  document.addEventListener(
    "keydown",
    function (e) {
      var flagName = getFlagForKeyCode(e.keyCode);
      if (typeof flagName !== "undefined") {
        flags[flagName] = true;
      }
    },
    false
  );

  document.addEventListener(
    "keyup",
    function (e) {
      var flagName = getFlagForKeyCode(e.keyCode);
      if (typeof flagName !== "undefined") {
        flags[flagName] = false;
      }
    },
    false
  );

  viewer.clock.onTick.addEventListener(function (clock) {

    updateMoonData();
    //setMoonSun3dLines();

    // Change movement speed based on the distance of the camera to the surface of the ellipsoid.
    var cameraHeight = ellipsoid.cartesianToCartographic(viewer.camera.position).height;
    moveRate = cameraHeight / 100.0;

    if (flags.moveForward) {    // W
      viewer.camera.moveForward(moveRate);
    }
    if (flags.moveBackward) {  // S
      viewer.camera.moveBackward(moveRate);
    }

    if (flags.moveUp) {        // Q
      viewer.camera.moveUp(moveRate);
    }
    if (flags.moveDown) {      // E
      viewer.camera.moveDown(moveRate);
    }
    if (flags.moveLeft) {      // A
      viewer.camera.moveLeft(moveRate);
    }
    if (flags.moveRight) {     // D
      viewer.camera.moveRight(moveRate);
    }

    if (chkGPS.checked) {
      if (currTime - baseTime > 10000) {
  console.log("GPS request.");
        baseTime = new Date().getTime();
        navigator.geolocation.getCurrentPosition(
          (success) => {
  console.log("GPS OK:",success.coords.latitude,success.coords.longitude, success.altitude);

            inputLon = success.coords.longitude;
            inputLat = success.coords.latitude;
            var cartographic = Cesium.Cartographic.fromDegrees(  inputLon, inputLat, 5000, new Cesium.Cartographic());

            lookAtMoon(); // calculates moon position and point it  -   debug: user option needed to track moon?

            // Temporarily go to GPS position but at approximate height from ellipsoid, then retrieve actual height (it can take some time):
            if (success.coords.altitude) {
              GPSalt = success.coords.altitude;
            } else {
              GPSalt = cartographic.height;
            }

            // Retrieve actual height:
            var positions = [ cartographic ];
            GPSheightPromise = Cesium.sampleTerrain(viewer.terrainProvider, 11, positions);
  console.log("Requesting GPS height for ", cartographic, ": ",GPSheightPromise);
            Cesium.when(GPSheightPromise, function( updatedPositions ) {
              height = updatedPositions[0].height;
  console.log(">>>>>>>>>> Updating GPS position with height.");
              flyLocGoogle.value = inputLat.toFixed(6) + "," + inputLon.toFixed(6) + "," + (height + 100.0).toFixed(0);
              // Reposition using now actual height:
              var tempDate2 = Cesium.JulianDate.toDate(viewer.clock.currentTime);
              var moonDataGPS = findMoon(tempDate2, inputLat, inputLon);
              CesiumCamera.flyTo({
                  destination: Cesium.Cartesian3.fromDegrees(success.coords.longitude, success.coords.latitude, height + 100.0),
                  orientation: {
                    heading: moonDataGPS.azRad,
                    pitch: moonDataGPS.altRad,
                    roll: 0.0,
                  }, // camera orientation
              }); // Cesium flyto
            }); // Cesium promise completion
          }, // navigator getCurrentPosition()
          (error) => {
            console.log("GPS Error:",error);
          }
        );
      } else {
        currTime = new Date().getTime();
      }
    } // checkGPS


    if (chkSync2D.checked) {
      manuallySetHeight = false;
      if (eventEnabled) {
        viewer.camera.changed.removeEventListener(syncMap);
        eventEnabled = false;
      }
      //syncCesium();
    } else {
      //manuallySetHeight = true;
      if (!eventEnabled) {
console.log("Enable syncmap");
        viewer.camera.changed.addEventListener(syncMap);
        eventEnabled = true;
      }
    } // chkSync2d






  });//viewer.clock.onTick.addEventListener

  function onLocationClicked(e) {
    L.DomEvent.disableClickPropagation(e);
  }


///////////////////////////////////////////


function getMousePosition(pickedPosition) {

    if (document.getElementById("target").checked) {
      document.getElementById("targetPos").innerHTML = "please wait...";
    }

    if (document.getElementById("camera").checked) {
      document.getElementById("cameraPos").innerHTML = "please wait...";
    }


    // Legge coordinate cartesiane del punto selezionato col mouse:
    var cartesian =  pickedPosition; //viewer.camera.pickEllipsoid(new Cesium.Cartesian3(e.clientX, e.clientY), ellipsoid);

    // Se le coordinate sono effettivamente disponibili, le elabora:
    if (cartesian) {
        var cartographic = ellipsoid.cartesianToCartographic(cartesian);
        var longitudeString = Cesium.Math.toDegrees(cartographic.longitude).toFixed(10);
        var latitudeString = Cesium.Math.toDegrees(cartographic.latitude).toFixed(10);
        var result = {"lat": latitudeString*1.0, "lon" : longitudeString*1.0};
console.log("Preliminary: ", cartesian, cartographic, ", LAT=", result.lat,  "LON=", result.lon, "ALT = please wait...");

        var positions = [ cartographic ];
        promiseClick = Cesium.sampleTerrain(viewer.terrainProvider, 11, positions);
console.log("Click promise for altitude " , cartographic , ": ", promiseClick);
        Cesium.when(promiseClick, function( updatedPositions ) {

console.log("Final: LAT=", updatedPositions[0].latitude*180.0/Math.PI, "LON=", updatedPositions[0].longitude*180.0/Math.PI, "ALT = ",updatedPositions[0].height);

          if (document.getElementById("target").checked) {
            document.getElementById("targetPos").innerHTML = (updatedPositions[0].longitude*180.0/Math.PI).toFixed(6)+ ", " + (updatedPositions[0].latitude*180.0/Math.PI).toFixed(6) + ",   " + updatedPositions[0].height.toFixed(0) + " (lon, lat, alt)"
            targetLatitudeDeg = updatedPositions[0].latitude*180.0/Math.PI;
            targetLongitudeDeg = updatedPositions[0].longitude*180.0/Math.PI;
          targetHeight = updatedPositions[0].height*1.0;
            targetAvailable = true;
          }

          if (document.getElementById("camera").checked) {
            document.getElementById("cameraPos").innerHTML = (updatedPositions[0].longitude*180.0/Math.PI).toFixed(6)+ ", " + (updatedPositions[0].latitude*180.0/Math.PI).toFixed(6) + ",   " + updatedPositions[0].height.toFixed(0) + " (lon, lat, alt)";
            cameraLatitudeDeg = updatedPositions[0].latitude*180.0/Math.PI;
            cameraLongitudeDeg = updatedPositions[0].longitude*180.0/Math.PI;
            cameraHeight = updatedPositions[0].height*1.0;
            cameraAvailable = true;
          }
        });

// Una volta determinate lat, long e alt delle due posizioni:
// - calcolare l'azimuth della seconda posizione (target) rispetto alla prima
// - trovare i casi in cui l'azimuth/altezza della Luna/Sole rispetto alla posizione 1 (camera)
//   e' in un certo intervallo rispetto all'azimuth della seconda posizione rispetto alla prima.
// - Poi verificare la situazione in https://www.peakfinder.org/?lat=41.9942&lng=12.6353&ele=138&azi=63.29&alt=-4.06&fov=46.8&date=2021-09-04T01:52:20Z&cfg=sm&name=

    } else {
        console.log("Cannot read coordinates of selected point, please retry");
          if (document.getElementById("target").checked) {
            document.getElementById("targetPos").innerHTML = "Please retry";
            targetAvailable = false;
          }

          if (document.getElementById("camera").checked) {
            document.getElementById("cameraPos").innerHTML = "Please retry";
            cameraAvailable = false;
          }
    }
}



//// End of cesium management //////




//////// Map management ///////////

  function lead0(i) {
    if (i<10) {
      return "0" + i;
    } else {
       return "" + i;
    }
  }


  function clearMap() {
    if  (mymap)
      mymap.removeEventListener("click", mapAlreadyClicked);

    if (markerLayer) {
      markerLayer.getLayers().forEach((m) => {
        m.remove();
      });
    }

    if (moonLine) {
      moonLine.setLatLngs([[0,0],[0,0]]);
    }

    myLines = [];
    linesCount = 0;
    tblResults.innerHTML = "";
    selectedLine = -1;
    mymap.on('click', onMapClick); // restore click event detection
    bufMarkerObserver = null; // Clear buffer of the oberver marker
    bufLineTarget = null;
    dayTable = document.createElement("table");
    dayTable.border = 1;
    drawTableHeader("xx/xx/xxxx");
    createDayRow(0,"xx","xx", "xxx", "xxx", "xxx", "xxx", "xxx", "xx", "xx", "xx", "xx");
    dayTable.appendChild(row);
    tblResults.appendChild(dayTable);
    spnObserverPopup.innerHTML = "Observer position:<br>"+
            "Google: lat, lon, 0:<br>xx.xxxx, xx.xxxx, 0<br><br>"+
            "Cesium: lon, lat, 0:<br>xx.xxxx, xx.xxxx, 0<br>";
    spnLinePopup.innerHTML = "Selected:<br>Date: xxxx/xx/xx xx:xx<br>";
  }

///////////////////////////////////////////////
/////////////// SCRIPT BEGINNING //////////////
///////////////////////////////////////////////

  //setupCesiumCompass();

viewer.camera.changed.addEventListener(() => {
	if (scene.globe.tilesLoaded) {
	    rngHeight.value = viewer.camera.positionCartographic.height;
	    setMoonSun3dLines()
	    updateCameraData();
	    updateMoonData();
	    updateLocationLines();
	    updateCameraLine();
	    setCompassRotation(-viewer.camera.heading * 180 / 3.14);
	    updateTooltips();


        
	} else {
		// Waiting tile loading...
	}

})

  // By default, the `camera.changed` event will trigger when the camera has changed by 50%
  // To make it more sensitive, we can bring down this sensitivity
  viewer.camera.percentageChanged = 0.0001;



  ///// Go to start position /////
/*  CesiumCamera.flyTo({
      destination: Cesium.Cartesian3.fromDegrees(12.635758, 41.993197, 667),
      orientation: {
        //heading: Cesium.Math.toRadians(60.0),
        pitch: Cesium.Math.toRadians(-90.0),
        roll: 0.0,
      },
  });

  changeZoom(); // as per zoom slider
  
 */
 
  
  ///////////
//if (firstRun) {
  urlParams = getURLParameters();
  var inputLat = parseFloat(urlParams.inputLat);
  var inputLon = parseFloat(urlParams.inputLon);
  var inputAlt = parseFloat(urlParams.inputAlt);
  var inputAz = parseFloat(urlParams.inputAz);
  var inputPitch = parseFloat(urlParams.inputPitch);
  var currentTime = new Date(urlParams.currentTime);
  var zoomVal = new Date(urlParams.zoom);
  


 if (
    urlParams &&
    urlParams.inputLat !== undefined &&
    urlParams.inputLon !== undefined &&
    urlParams.inputAlt !== undefined  &&
    urlParams.inputAz !== undefined &&
    urlParams.inputPitch !== undefined &&
    urlParams.currentTime !== undefined  &&
    urlParams.zoom !== undefined

  ) {
        populateInterfaceFromURL(urlParams);
        gotoLocation();
        console.log("Showing url-specifiied location/time")
    } else {
        console.log("Showing predefined location and current time", urlParams)
    }
    firstRun = false;
//}
  
  //////////
  
  
  

  dayTable = document.createElement("table");
  dayTable.border = 1;
  drawTableHeader("xx/xx/xxxx");
  createDayRow(0,"xx","xx", "xxx", "xxx", "xxx", "xxx", "xxx", "xx", "xx", "xx", "xx");
  dayTable.appendChild(row);
  tblResults.appendChild(dayTable);


  TODAY = new Date();
  document.getElementById("startDate").value = lead0(TODAY.getDate()) + "/" + (lead0(TODAY.getMonth() +1 )) + "/" + TODAY.getFullYear(); // Pre-write date in non-English format, hence DD/MM/YYYY

  mymap = L.map('mapid').setView([41.9805, 12.6328], 15);
  mymap.on('click', onMapClick);
  compassLayer = L.layerGroup().addTo(mymap);
  moonLineLayer = L.layerGroup().addTo(mymap);
  cameraLineLayer = L.layerGroup().addTo(mymap);
  myLocationsLayer = L.layerGroup().addTo(mymap);

  clearMap();


  crosshairIcon = L.icon({
      iconUrl: 'compass-transparent-2-mini.png',
      iconSize:     [320, 320], // size of the icon
      iconAnchor:   [160, 160], // point of the icon which will correspond to marker's location
      clickable : false,
  });
  crosshair = new L.marker(mymap.getCenter(), {icon: crosshairIcon, clickable:false});
  crosshair.setOpacity(0.5);
  crosshair.addTo(compassLayer);
  mymap.getPanes()["mapPane"].style.zIndex     =   10
  mymap.getPanes()["tilePane"].style.zIndex    =   20
  mymap.getPanes()["shadowPane"].style.zIndex  =   30
  mymap.getPanes()["markerPane"].style.zIndex  =   40
  mymap.getPanes()["overlayPane"].style.zIndex =   50
  mymap.getPanes()["popupPane"].style.zIndex   =   60
  mymap.getPanes()["tooltipPane"].style.zIndex =   70

  moonLine = L.polyline(
   [[0,0],
   [0,0]],
    {weight : 3},
  ).addTo(moonLineLayer);

  cameraLine = L.polyline(
   [[0,0],
   [0,0]],
    {weight : 5, color: '#FF4444'},
  ).addTo(cameraLineLayer);


  moonLine3d = null;
  sunLine3d = null;
  createMoonSun3dLines();


// debug per tooltip ////////////////
/*myLocations = [
{ lat : 41.902139, lng : 12.453384, height: 213, name : "Cupola San Pietro"},
]*/
/////////////////////////////


  myLocationsCount = 0;
  myLocationLine = [];
  myLocationEdgeTooltips = [];
  var tooltipsCount = 0;
  spnLocations.innerHTML = "";
  loclist = document.createElement("select");
  loclist.id = "lstLocations";
  myLocations.forEach((location) => {
//    if (!location.observer) {
      var locationPos = {lat: location.lat, lng: location.lng, height: location.height};
      var lcoationDir = getAltAz(mymap.getCenter(), locationPos);
      var locationAlt = lcoationDir.pitchDeg;
      var locationAz = lcoationDir.headingDeg;
      var popupText = location.name + "<br>Alt: " + locationAlt.toFixed(0) + ", Az: " + locationAz.toFixed(0);
      var opt = document.createElement("option");
      opt.value = myLocationsCount;
      opt.innerHTML = location.name;
      loclist.appendChild(opt);
      spnLocations.appendChild(loclist);
      //spnLocations.innerHTML += location.name + '<button onclick="pointedLocation = ' + myLocationsCount + '; lookAt('  + myLocationsCount +  ',1)">Look at</button> <button onclick="lookAt('  + myLocationsCount  + ',2)">Go to</button><br>';
      myLocationLine[myLocationsCount] = L.polyline(
       [[0,0],
       [0,0]],
        {weight : 2, color: '#000000', opacity: 0.4},
      )
      .bindPopup(popupText)
      .bindTooltip(location.name, {sticky : true})
      .addTo(myLocationsLayer)
      .bringToFront();
      myLocationLine[myLocationsCount].getTooltip().options.interactive = true;

      // Create 4 popups for each location line, to be updated in realtime to map edges intersections

      var NESW = ["N","E","S","W"];
      for (var tt=0; tt<4; tt++) {
        myLocationEdgeTooltips[tooltipsCount + tt] = L.tooltip();
        myLocationEdgeTooltips[tooltipsCount + tt].setLatLng(mymap.getCenter());
        myLocationEdgeTooltips[tooltipsCount + tt].setContent(location.name +  NESW[tt]);
        myLocationEdgeTooltips[tooltipsCount + tt].addTo(mymap);
        myLocationEdgeTooltips[tooltipsCount + tt].closePopup(myLocationEdgeTooltips[tooltipsCount + tt]); // debug: needed?
      }
        tooltipsCount += 4;
//    } else {
//     spnLocations.innerHTML += "(" + location.name + '<button onclick="pointedLocation = ' + myLocationsCount + '; lookAt('  + myLocationsCount +  ',1)">Look at</button> <button onclick="lookAt('  + myLocationsCount  + ',2)">Go to</button>)<br>';
//    }
    myLocationsCount++;
  });

  var br = document.createElement("BR");
  spnLocations.appendChild(br);

  var bt = document.createElement("button");
  bt.innerHTML = "Fly";
  bt.addEventListener("click",locationSelected);
  spnLocations.appendChild(bt);

  var bt = document.createElement("button");
  bt.innerHTML = "Look";
  bt.addEventListener("click",locationSelected);
  spnLocations.appendChild(bt);

  mymap.on('move', function(e) {
    crosshair.setLatLng(mymap.getCenter());
    if (bufLineTarget !== null) {
      var mapCenter = mymap.getCenter();
      var moonDest = destination(mymap.getCenter(),bufLineTarget.moonAz, (100000));
      moonLine.setLatLngs([[mapCenter.lat,mapCenter.lng],[moonDest.lat, moonDest.lng]])
      moonLine.bringToFront();
    } else {
    }

  });




  bufMarkerObserver = null; // Clear buffer of the oberver marker
  mymap.on('dragend', onMapDrag);
  mymap.on('move', onMapDrag);
  var popup = L.popup();
  markerLayer = L.layerGroup().addTo(mymap);

  L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
  //L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw', {
    maxZoom: 18,
    attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, ' +
      'Imagery ÃÂ© <a href="https://www.mapbox.com/">Mapbox</a>',
    id: 'mapbox/streets-v11',
    tileSize: 512,
    zoomOffset: -1
  }).addTo(mymap);


  rngHeight.value = viewer.camera.positionCartographic.height;


function locationSelected(e) {
var sel = loclist.options.selectedIndex;
console.log( loclist[sel].innerText, myLocations[sel]);
/*
pointedLocation = ' + myLocationsCount + ';
lookAt('  + myLocationsCount +  ',1)


lookAt('  + myLocationsCount  + ',2)

*/

  console.log(e);
  if (e.target.innerHTML === "Look") {
    lookAt(sel,1)
  }

  if (e.target.innerHTML === "Fly") {
    lookAt(sel,2)
  }

}


  function updateLocationLines() {
    ////// Update my locations lines:
    myLocationsCount = 0;
    myLocations.forEach((location) => {
//        if (!location.observer) {
          var mapCenter = mymap.getCenter();
          var myLocationDest = {lat : location.lat, lng: location.lng};
          var lcoationDir = getAltAz(mapCenter, myLocationDest);
          var locationAlt = lcoationDir.pitchDeg;
          var locationAz = lcoationDir.headingDeg;
          var popupText = location.name + "<br>Alt: " + locationAlt.toFixed(0) + ", Az: " + locationAz.toFixed(0);
          myLocationLine[myLocationsCount].setLatLngs([[mapCenter.lat,mapCenter.lng],[myLocationDest.lat, myLocationDest.lng]]);
          myLocationLine[myLocationsCount].bringToFront();
          myLocationLine[myLocationsCount].getPopup().setContent(popupText)
//        }
        myLocationsCount++;
    });
    spnMapCenter.innerHTML = mymap.getCenter().lat.toFixed(6) + ", " + mymap.getCenter().lng.toFixed(6) + "<br><br>Map edges:<br>" +
      mymap.getBounds().getNorth().toFixed(6) + ",<br>" +
      mymap.getBounds().getWest().toFixed(6) + " / " +
     mymap.getBounds().getEast().toFixed(6) + ",<br>" +
      mymap.getBounds().getSouth().toFixed(6) + ",<br>";
  }


function updateMoonData() {
    var tempLat = (viewer.camera.positionCartographic.latitude*180/Cesium.Math.PI).toFixed(6);
    var tempLon = (viewer.camera.positionCartographic.longitude*180/Cesium.Math.PI).toFixed(6);
    var tempAlt = (viewer.camera.positionCartographic.height).toFixed(0)*1;
    var tempDateJS = Cesium.JulianDate.toDate(viewer.clock.currentTime);
    var moonData = findMoon(tempDateJS, tempLat, tempLon, false); // calculate moonAlt and moonAz
    spnMoonAlt.innerHTML = (moonData.altRad*180/3.14).toFixed(1);
    spnMoonAz.innerHTML = (moonData.azRad*180/3.14).toFixed(1);
}


function updateCameraData() {
    var tempLat = (viewer.camera.positionCartographic.latitude*180/Cesium.Math.PI).toFixed(6);
    var tempLon = (viewer.camera.positionCartographic.longitude*180/Cesium.Math.PI).toFixed(6);
    var tempAlt = (viewer.camera.positionCartographic.height).toFixed(0)*1;
    spnCameraPitchEl.innerHTML = (viewer.camera.pitch*180/Cesium.Math.PI).toFixed(1);
    spnCameraYawHeading.innerHTML = (viewer.camera.heading*180/Cesium.Math.PI).toFixed(1);
    //spnCameraFOV.innerHTML = (viewer.camera.frustum.fov*180/Cesium.Math.PI).toFixed(0);
    spnCameraLoc.innerHTML = "Lat, Lon, Alt (Google):<br>" +  tempLat + ", " + tempLon + ", " + tempAlt + "m<br><br>" +
      "Lon, Lat, Alt (Cesium):<br>" +  tempLon + ", " + tempLat + ", " + tempAlt + "m<br>";
}

function updateCameraLine() {
  /////////// Draw line pointing to camera direction /////////
      var height = Cesium.Cartographic.fromCartesian(viewer.camera.position).height
      oldHeight = height;
      var pitchRad = /*Cesium.Math.PI  - */viewer.camera.pitch;
//console.log("pitchRad=",pitchRad);
      var lineLength = height / Math.tan(pitchRad);
      if (lineLength > 100000) {
        lineLength = 100000
      }
      var mapCenter = mymap.getCenter();
      var cameraHeading = viewer.camera.heading * 180 / 3.14;
//console.log("cameraHeading1=",cameraHeading);
      if (viewer.camera.pitch*180/Cesium.Math.PI  < 0) {
        cameraHeading = cameraHeading - 180;
      } else {
        //
      }
//console.log("cameraHeading2=",cameraHeading);
      var cameraDest = destination(mymap.getCenter(),cameraHeading , (lineLength));
      cameraLine.setLatLngs([[mapCenter.lat,mapCenter.lng],[cameraDest.lat, cameraDest.lng]]);
  ///////////////

}


function updateLookDirection() {
    if (chkTrack.checked) {
      lookAt(pointedLocation,1);
    } // chkTrack


    if (chkLockH.checked) {

    } // chkLockH
}


function drawTableHeader(day, moonTimes, sunTimes) {
  if (typeof moonTimes === "undefined") moonTimes = "xx:xx/xx:xx";
  if (typeof sunTimes === "undefined") sunTimes = "xx:xx/xx:xx";
    row = document.createElement("TR");

      cell = document.createElement("TD");
      cell.innerHTML = day;
      row.appendChild(cell);

      cell = document.createElement("TD");
      cell.innerHTML = "Moon";
      cell.setAttribute("colspan",3);
      cell.setAttribute("style","text-align: center;");
      row.appendChild(cell);

      cell = document.createElement("TD");
      cell.innerHTML = "Sun";
      cell.setAttribute("colspan",2);
      cell.setAttribute("style","text-align: center;");
      row.appendChild(cell);

    dayTable.appendChild(row);


    row = document.createElement("TR");

      cell = document.createElement("TD");
      cell.innerHTML = "";
      row.appendChild(cell);

      cell = document.createElement("TD");
      cell.innerHTML = moonTimes;
      cell.setAttribute("colspan",3);
      cell.setAttribute("style","text-align: center;");
      row.appendChild(cell);

      cell = document.createElement("TD");
      cell.innerHTML = sunTimes;
      cell.setAttribute("colspan",2);
      cell.setAttribute("style","text-align: center;");
      row.appendChild(cell);

    dayTable.appendChild(row);


    row = document.createElement("TR");

      cell = document.createElement("TD");
      cell.innerHTML = "Time";
      row.appendChild(cell);

      cell = document.createElement("TD");
      cell.innerHTML = "Phase";
      row.appendChild(cell);

      cell = document.createElement("TD");
      cell.innerHTML = "Alt &deg;";
      row.appendChild(cell);

      cell = document.createElement("TD");
      cell.innerHTML = "Az &deg;";
      row.appendChild(cell);

      cell = document.createElement("TD");
      cell.innerHTML = "Alt &deg;";
      row.appendChild(cell);

      cell = document.createElement("TD");
      cell.innerHTML = "Az &deg;";
      row.appendChild(cell);

/*     cell = document.createElement("TD");
      cell.innerHTML = "Local rise";
      row.appendChild(cell);

      cell = document.createElement("TD");
      cell.innerHTML = "Local set";
      row.appendChild(cell);*/

    dayTable.appendChild(row);
}


  function clearLineBuffer() {
      // upon clicking on map, the marker popup disappears, so clean up its buffer
      bufLineTarget = null;
  }


  function highlightLine(line) {
    myLines.forEach( (oldline) => {
      if (oldline.options.lineCount !== selectedLine) {
        oldline.setStyle({color : DEFAULT_LINE_COLOR, weight : 5})
        document.getElementById("result_" + oldline.options.lineCount).setAttribute("style","background-color:#FFFFFF");
      } else {
        myLines[selectedLine].setStyle({color : SELECTED_LINE_COLOR, weight : 5})
        document.getElementById("result_" + selectedLine).setAttribute("style","background-color:" + SELECTED_LINE_COLOR);
      }
    });

    if (line) {
      line.setStyle({color : HIGHLIGHT_LINE_COLOR, weight : 5})
      line.bringToFront();
      document.getElementById("result_" + line.options.lineCount).setAttribute("style","background-color:" + HIGHLIGHT_LINE_COLOR);
    }
  }

  function highlightLinePermanently(lineNum) {
console.log("Permanent:",lineNum,selectedLine);
    myLines.forEach( (oldline) => {
      if (oldline.options.lineCount !== selectedLine) { // Remove highlighting from all lines but selected ones
        oldline.setStyle({color : DEFAULT_LINE_COLOR, weight : 5})
        document.getElementById("result_" + oldline.options.lineCount).setAttribute("style","background-color:#FFFFFF");
      } else {
        if (myLines[lineNum]) {
          myLines[lineNum].setStyle({color : "#5555AA", weight : 5}) // Highlight line
console.log("MYLINE:", 	myLines[lineNum]);	  
        }
        if (document.getElementById("result_" + lineNum)) {
          document.getElementById("result_" + lineNum).setAttribute("style","background-color:#5555AA"); // Highlight table row
        }
      }
    });
  }


  function markerDragStart(e) {
    oldObserverLat = e.target.getLatLng().lat;
    oldObserverLng = e.target.getLatLng().lng;
  }


  function markerDragEnd(e) {

    ///////// Update  results upon dragging observer marker

    clearMap();

    newObserverPos = e.target.getLatLng();
      newObserverLat = newObserverPos.lat*1;
      newObserverLng = newObserverPos.lng*1;

    // Simulate manual click on map using new observer position:
    onMapClick({latlng :{lat: newObserverLat , lng: newObserverLng}});

  }

function mapAlreadyClicked(e) {
/*console.log("Already clicked");
  if (confirm("Obseved already set. Set new position?")) {
    mymap.removeEventListener("click", mapAlreadyClicked); // debug: needed? Will it be overwritten or repeated?!?
    clearMap();
    onMapClick(e); // pass event to real function
  } else  {
    // do nothing
  }*/
}


  function onMapClick(e) {
//console.log("mapclick");
    mymap.removeEventListener("click", onMapClick); // disable click events , to be re-enabled by user by "CLEAR MAP" button
    mymap.addEventListener("click", mapAlreadyClicked); // enable warning message
    tblResults.innerHTML = "";

    myLines = [];
    destMarkerClose = [];
    linesCount = 0;

    startDate = document.getElementById("startDate").value;
    if ((startDate.length != 10) || (startDate[2] != "/") || (startDate[5] != "/")) {
      alert("Please use format DD/MM/YYYY");
      return;
    }

    startDateEnglish = startDate.substr(3,2) + "/" + startDate.substr(0,2) + "/" + startDate.substr(6,4) + " 12:00:00";
    startDateJS = new Date(startDateEnglish);

    popupObserverText = "<br>Observer position: <br>Google: lat,lon,0: <br>"+
      e.latlng.lat.toFixed(6) + " , " +
      e.latlng.lng.toFixed(6) +  ",0<br><br>" +
      "Cesium: lon, lat,0:<br>" +
      e.latlng.lng.toFixed(6) + "," +
      e.latlng.lat.toFixed(6) +
      ",0<br><button onclick='posFromObserver()'>Copy</button><button onclick='posFromObserver();gotoLocation()'>Fly</button>";

    // Create marker on clicked position:
    markerA = L.marker([e.latlng.lat, e.latlng.lng], {draggable : true})
      .addTo(markerLayer)
      .on("dragstart",markerDragStart)
      .on("dragend",markerDragEnd)
     .bindPopup(popupObserverText);

    spnObserverPopup.innerHTML = markerA.getPopup().getContent();

    bufMarkerObserver =  {
        lng : e.latlng.lng.toFixed(6),
        lat : e.latlng.lat.toFixed(6)
    } // Store for copying to Cesium if requisted by user.
    flyLocGoogle.value = bufMarkerObserver.lat + "," + bufMarkerObserver.lng + "," + (100).toFixed(0);



    document.getElementById("observingLocation1").innerHTML = "LAT, LON, 0 = " + e.latlng.lat.toFixed(6) + ", " + e.latlng.lng.toFixed(6) + ",0";
    document.getElementById("observingLocation2").innerHTML = "LON, LAT, 0 = " + e.latlng.lng.toFixed(6) + ", " + e.latlng.lat.toFixed(6) + ",0";

    BASE_DIST = 1;
    delta = 0;
    hourInterval = document.getElementsByName("hourInterval");
    customSelected = false;
      for (radioIndex=0; radioIndex < hourInterval.length; radioIndex++) {
        if (hourInterval[radioIndex].checked) {
            rangeSelect = hourInterval[radioIndex].value; // sunrise, sunset, custom
        }
      }

    selectedRange = [];



    for (dayIndex = 0; dayIndex < nextDays.value; dayIndex++) {
      dayTable = document.createElement("table");
      dayTable.border = 1;
      atLeastOneResult = false;
      dayRowShown = false;
      dayHeaderPrinted = false;
      baseDate_ms = startDateJS.getTime() + dayIndex * 24 * 3600 * 1000; // Used to calculate special times of the day (sunset, sunrise,...)
      baseDateJS = new Date(baseDate_ms)
      baseDateReadable = lead0(baseDateJS.getDate()) + "/" + lead0(baseDateJS.getMonth() + 1 ) + "/" + lead0(baseDateJS.getFullYear());

// console.log("Calcolo per data n." , dayIndex, ": " , baseDateReadable);

      //specialTimes = SunCalc.getSunTimes(baseDateJS, e.latlng.lat,  e.latlng.lng);
      specialTimes = getSunTimesMeeus(baseDateJS, e.latlng.lat,  e.latlng.lng, 0);
//console.log("SUN:", specialTimes);


      sunRise = specialTimes.riseJS;
// console.log("sunRise for ", baseDateJS, " :  ", sunRise);
 		sunRise_ms = sunRise.getTime();// - sunRise.getTimezoneOffset()*60000;
      selectedRange["sunrise"] = sunRise_ms;
      sunRiseH = new Date(sunRise_ms).getHours();
      sunRiseM = new Date(sunRise_ms).getMinutes();
// console.log("sunRiseM:", sunRiseH,sunRiseM);

      sunSet = specialTimes.setJS;
      sunSet_ms = sunSet.getTime();// - sunSet.getTimezoneOffset()*60000;
      selectedRange["sunset"] = sunSet_ms;
      sunSetH = new Date(sunSet_ms).getHours();
      sunSetM = new Date(sunSet_ms).getMinutes();

//console.log("sunSet for ", baseDateJS, " :  ", sunSet);

      sunTimesStr = lead0(sunRiseH) + ":" + lead0(sunRiseM) + "/" + lead0(sunSetH) + "." + lead0(sunSetM);
//console.log("sunTimesStr:", sunTimesStr);

      localRiseDate = new Date(sunRise.getTime());// - sunRise.getTimezoneOffset() * 60000);
      localRiseH = localRiseDate.getHours();
      localRiseM = localRiseDate.getMinutes();

      localSetDate = new Date(sunSet.getTime());// - sunSet.getTimezoneOffset() * 60000);
      localSetH = localSetDate.getHours();
      localSetM = localSetDate.getMinutes();
//console.log("localRiseH:", localRiseH,localRiseM,localSetH,localSetM);

//      moonSpecialTimes = SunCalc.getMoonTimes(baseDateJS, e.latlng.lat,  e.latlng.lng);
      moonSpecialTimes = getMoonTimesMeeus(baseDateJS, e.latlng.lat,  e.latlng.lng, 0);
//console.log("MOON:", moonSpecialTimes);
      moonRise = moonSpecialTimes.riseJS;
      moonRise_ms = moonRise.getTime();// sunSet.getTimezoneOffset()*60000;
      moonRiseH = new Date(moonRise_ms).getHours();
      moonRiseM = new Date(moonRise_ms).getMinutes();

      moonSet = moonSpecialTimes.setJS;
      moonSet_ms = moonSet.getTime();// sunSet.getTimezoneOffset()*60000;
      moonSetH = new Date(moonSet_ms).getHours();
      moonSetM = new Date(moonSet_ms).getMinutes();

      moonTimesStr = lead0(moonRiseH) + ":" + lead0(moonRiseM) + "/" + lead0(moonSetH) + "." + lead0(moonSetM);

//console.log(baseDateJS + "  Sun: " + lead0(sunRiseH) + ":" + lead0(sunRiseM) + "-" +  lead0(sunSetH) + ":" + lead0(sunSetM) + ", Moon: " + lead0(moonRiseH) + ":" + lead0(moonRiseM) + "-"  + lead0(moonSetH) + ":" + lead0(moonSetM));

//console.log(">>>>>>>>>>>>>>>>>>",radioIndex);
      ////// Define central date around which to calculate moon data /////
      if (rangeSelect != "custom") {
        refDate = selectedRange[rangeSelect];
        refDateJS = new Date(refDate);
      } else { // if "custom" is selected
console.log("Custom range");
        startRange = new Date(startCustomRange).getTime()/1000;
        endRange = new Date(endCustomRange).getTime()/1000;
        totalRange = endRange - startRange;
        refDateJS = new Date(startCustomRange + totalRange/2); // set as reference date the central date of the range
      }
      refDateReadable = refDateJS.getFullYear() + "/" + (refDateJS.getMonth() +1 ) + "/" + refDateJS.getDate() + " " + lead0(refDateJS.getHours()) + ":" + lead0(refDateJS.getMinutes());

//console.log("Calcolo tra " + new Date(refDate -substeps.value * STEP_SECONDS * 1000) +  " e " + new Date(refDate  + substeps.value * STEP_SECONDS * 1000) );
      for (var stepIndex = -substeps.value; stepIndex <= substeps.value; stepIndex++) { // Calculate for times around the reference time, which can be custom or sunset or sunrise
        moonDate_ms = refDate + stepIndex * STEP_SECONDS * 1000
        moonDate = new Date(moonDate_ms);
        moonDateReadable = moonDate.getDate() + "/" + (moonDate.getMonth() +1 ) + "/" + moonDate.getFullYear() + " " + lead0(moonDate.getHours()) + ":" + lead0(moonDate.getMinutes());

var moonData = findMoon(moonDate,  e.latlng.lat,  e.latlng.lng, false);


        moonPhase = (mooncalcMeeus(moonDate,  e.latlng.lat,  e.latlng.lng, 0).moonIllumFractionDetailPercentage * 100).toFixed(0)*1.0; 
                moonAltitude = moonData.altDeg.toFixed(1)*1.0;//moonData.moonAltitudeRefractionDegrees.toFixed(0)*1.0;
        moonAzimuth = moonData.azDeg.toFixed(1)*1.0; //moonAzimuthDegrees.toFixed(0)*1.0;
//console.log(moonDateReadable, moonPhase, moonAzimuth , moonAltitude);

        sunpos = SunCalc.getPosition(moonDate, e.latlng.lat,  e.latlng.lng);
        sunAz = sunpos.azimuthDegrees.toFixed(1)*1.0;
        sunAlt = sunpos.altitudeDegrees.toFixed(1)*1.0;
        fullDate = moonDate.getFullYear() + "/" + (moonDate.getMonth()+1) + "/" + moonDate.getDate()+ " " + (moonDate.getHours()) + ":"+ moonDate.getMinutes();
        if ((moonPhase*1.0 > minPhase.value ) && (moonPhase*1.0 <= maxPhase.value)) {
          highlight="#PHASE#";
          if ((moonAltitude*1.0 > minAlt.value) && (moonAltitude*1.0 <= maxAlt.value)) {
            highlight += "#ALT#";
            if ((moonAzimuth*1.0 > minAz.value) && (moonAzimuth*1.0 <= maxAz.value)) {
//console.log(">>>>>>>>>>>>", moonDateReadable, moonPhase, moonAltitude, moonAzimuth );
              highlight += "#AZ#";
              atLeastOneResult = true;
              if (!dayHeaderPrinted) {
                drawTableHeader(baseDateReadable, moonTimesStr, sunTimesStr);
                dayHeaderPrinted = true;
              }

              UTCMoonDate = new Date(moonDate.getTime());
              UTCMoonY = UTCMoonDate.getFullYear();
              UTCMoonMo = UTCMoonDate.getMonth() + 1.0;
              UTCMoonD = UTCMoonDate.getDate();
              UTCMoonH = UTCMoonDate.getHours();
              UTCMoonM = UTCMoonDate.getMinutes();
              UTCMoonDateStr = UTCMoonY + "-" + UTCMoonMo + "-" + UTCMoonD + " " + UTCMoonH + ":" + UTCMoonM;

              localMoonDate = new Date(moonDate.getTime());// - moonDate.getTimezoneOffset() * 60000);
              localMoonH = localMoonDate.getHours();
              localMoonM = localMoonDate.getMinutes();

              createDayRow(linesCount, localMoonH, localMoonM, moonPhase, moonAltitude, moonAzimuth, sunAlt, sunAz, localRiseH , localRiseM, localSetH, localSetM, UTCMoonDateStr);
              dayTable.appendChild(row); // Append result for the table of current day

              destClose = destination(markerA.getLatLng(), moonAzimuth*1.0, (BASE_DIST + delta) * 1000);
              destFar = destination(markerA.getLatLng(), moonAzimuth*1.0, LINE_LENGTH_KM  *1000 );
              delta += 0.3;


              myOptions = {
                weight : 4, // useful only for lines, ignored in markers
                color : DEFAULT_LINE_COLOR,
                myTime : fullDate,
                mySource : {lng: e.latlng.lng, lat: e.latlng.lat },
                myDest : { lng: destFar.lng, lat: destFar.lat },
                myAlt : moonAltitude,
                myAz : moonAzimuth,
              };

              markerPopupText = "Date: " +
                fullDate + "<br>" +
                " Sun rise: " + localRiseH + ":" + localRiseM + "<br> Sun set: " +  localSetH + ":"+localSetM + "<br>" +
                "Moon:<br>" +
                "&nbsp;&nbsp;Altitude: " +   moonAltitude +   "&deg;<br>" +
                "&nbsp;&nbsp;Azimuth: " +   moonAzimuth +    "&deg;<br>" +
                "&nbsp;&nbsp;Phase: " +   moonPhase +  "%<br>" +
                "Sun:<br>"+
                "&nbsp;&nbsp;Az: " +  sunAz +  "&deg;<br>"+
                "&nbsp;&nbsp;Alt: " + sunAlt +  "&deg;<br>";

              markerButtons =  "<button onclick='destFromLine()'>Copy</button><button onclick='posFromObserver();destFromLine();gotoLocation()'>Fly</button>";


             ///// Add line for this result:
              myLines[linesCount] = L.polyline([
               [e.latlng.lat, e.latlng.lng],
                [destFar.lat, destFar.lng]],
                {...myOptions, popupText :   markerPopupText, lineCount: linesCount },
              )
              .on("click",function(thisLineEvent) {
console.log("Line clicked, drawing moon ",thisLineEvent);
                //L.DomEvent.disableClickPropagation(e); // debug
                options = thisLineEvent.target.options;

                bufLineTarget = {
                    lng : options.myDest.lng,
                    lat : options.myDest.lat,
                    time : options.myTime,
                    moonAlt :  options.myAlt,
                    moonAz :  options.myAz
                }  // Store for copying to Cesium if requisted by user.

               var mapCenter = mymap.getCenter();
                var moonDest = destination(mymap.getCenter(),bufLineTarget.moonAz, (100000));
                moonLine.setLatLngs([[mapCenter.lat,mapCenter.lng],[moonDest.lat, moonDest.lng]]);
                moonLine.setStyle({color : MOON_LINE_COLOR})
                spnLinePopup.innerHTML = "SELECTED:<br>" + thisLineEvent.target.options.popupText + markerButtons;
                selectedLine = thisLineEvent.target.options.lineCount;
                highlightLinePermanently(thisLineEvent.target.options.lineCount);

              }) // onclick function for the line

              .on("mouseover", function (thisLineEvent) {
                highlightLine(thisLineEvent.target);
              })
              .addTo(markerLayer)
              .bindTooltip(markerPopupText, {sticky : true})
              //.bindPopup(markerPopupText);

/*
             ///////// Add images representing Sun and Moon above horizon /////////////
              bottomLeftX = destClose.lng - RECT_WIDTH/2
              bottomLeftY = destClose.lat - RECT_HEIGHT/2
              topRightX = destClose.lng + RECT_WIDTH/2
              topRightY = destClose.lat + RECT_HEIGHT/2

              var bounds = [[bottomLeftY, bottomLeftX], [topRightY, topRightX]];
              L.rectangle(bounds, {color: "#ffffff", weight: 1, fillOpacity:1}).addTo(markerLayer); // white filled rectangle

              sunCenterX = bottomLeftX + RECT_WIDTH/4;
              sunCenterY = bottomLeftY + RECT_HEIGHT/2;

              moonCenterX = bottomLeftX + 3*RECT_WIDTH/4;
              moonCenterY = bottomLeftY + RECT_HEIGHT/2;

              SUN_ALT_FACTOR = RECT_HEIGHT / 180;
              sunCenterY += sunAlt * SUN_ALT_FACTOR;

              L.circle([sunCenterY, sunCenterX], {radius : 10, color: "#FFAA00", fillOpacity:1}).addTo(markerLayer);
              L.circle([moonCenterY, moonCenterX], {radius : 10, color: "#888888", fillOpacity:1}).addTo(markerLayer);
              L.circle([moonCenterY, moonCenterX], {radius: 10, color: "#666666", fillOpacity:1}).setAngles(0, 360  * moonPhase/100).addTo(markerLayer)

              bounds = [[bottomLeftY , bottomLeftX + RECT_WIDTH/2], [topRightY - RECT_HEIGHT/2 , topRightX]]; // horizon box left
              L.rectangle(bounds, {color: "#AA0000", weight: 1, fillOpacity:0.7}).addTo(markerLayer);

              bounds = [[bottomLeftY , bottomLeftX], [topRightY - RECT_HEIGHT/2 , topRightX - RECT_WIDTH/2]]; // horizon box right
              L.rectangle(bounds, {color: "#AA0000", weight: 1, fillOpacity:0.7}).addTo(markerLayer);

              bounds = [[bottomLeftY, bottomLeftX], [topRightY, topRightX]];
              L.rectangle(bounds, {color: "#000000", weight: 2, fillOpacity:0}).addTo(markerLayer); // rectangle black border

              bounds = [[bottomLeftY, bottomLeftX], [topRightY, topRightX-0.002]];
              L.rectangle(bounds, {color: "#000000", weight: 2, fillOpacity:0}).addTo(markerLayer); // vertical separator
              ///////////////////////////////////////////////////////////////////////
*/

/*

             ////// Add marker for this result:
              destMarkerClose[linesCount] = L.marker(
                [destClose.lat, destClose.lng],
                { ...myOptions, line: myLines[linesCount], popupText :   markerPopupText, lineCount: linesCount  },
              ).addTo(markerLayer)
               .bindTooltip(markerPopupText, {sticky : true});

              ///// Store data if clicked
              destMarkerClose[linesCount].on("click",function(m) {
                    bufLineTarget = {
                        lng : options.myDest.lng,
                        lat : options.myDest.lat,
                        time : options.myTime,
                        moonAlt :  options.myAlt,
                        moonAz :  options.myAz,
                    }  // Store for copying to Cesium if requisted by user.
                    var mapCenter = mymap.getCenter();
                    var moonDest = destination(mymap.getCenter(),bufLineTarget.moonAz, (100000));
                    moonLine.setLatLngs([[mapCenter.lat,mapCenter.lng],[moonDest.lat, moonDest.lng]]);
                    moonLine.setStyle({color : MOON_LINE_COLOR})

                    spnLinePopup.innerHTML = "SELECTED:<br>" + m.target.options.popupText;
                    highlightLine(m.target.options.line);
              } );

            destMarkerClose[linesCount].on("drag",function(e) {
              console.log(e);
              }
            );

*/
            ///////////////////


              linesCount++;

            } // moonAzimuth
          } // monaltitude
        } else { // moonphase
          //highlight="";
        } // moonphase
      } // day substeps
      if (atLeastOneResult) {
        dayTableRow = document.createElement("TR");
        dayTableRowCell = document.createElement("TD");
        dayTableRowCell.appendChild(dayTable);
        dayTableRow.appendChild(dayTableRowCell);
        tblResults.appendChild(dayTableRow);
      } // oneresult
  } // dayIndex
        myLines.forEach((myLine) => {

        });
  status.innerHTML = "done";
  } // function



function createDayRow(linesCount, moonDateH, moonDateM, moonPhase, moonAltitude, moonAzimuth, sunAlt, sunAz, sunRiseH , sunRiseM, sunSetH, sunSetM, d) {
              row = document.createElement("TR");
              row.setAttribute("id","result_" + linesCount);
              row.setAttribute("name","result_" + linesCount);

              cell = document.createElement("TD");
              cell.innerHTML = lead0(moonDateH) + ":"+ lead0(moonDateM);
              cell.setAttribute("style","text-align: center;");
              row.appendChild(cell);

              cell = document.createElement("TD");
              cell.innerHTML = moonPhase + "%";
              cell.setAttribute("style","text-align: center;");
              row.appendChild(cell);

              cell = document.createElement("TD");
              cell.innerHTML = moonAltitude;//.toFixed(2);
              cell.setAttribute("style","text-align: center;");
              row.appendChild(cell);

              cell = document.createElement("TD");
              cell.innerHTML = moonAzimuth;//.toFixed(2);
              cell.setAttribute("style","text-align: center;");
              row.appendChild(cell);

              cell = document.createElement("TD");
              cell.innerHTML = sunAlt;//.toFixed(2);
              cell.setAttribute("style","text-align: center;");
              row.appendChild(cell);

              cell = document.createElement("TD");
              cell.innerHTML = sunAz;//.toFixed(2);
              cell.setAttribute("style","text-align: center;");
              row.appendChild(cell);
/*

              cell = document.createElement("TD");
              cell.innerHTML = lead0(sunRiseH) + ":" + lead0(sunRiseM);
              cell.setAttribute("style","text-align: center;");
              row.appendChild(cell);

              cell = document.createElement("TD");
              cell.innerHTML = lead0(sunSetH) + ":" + lead0(sunSetM);
              cell.setAttribute("style","text-align: center;");
              row.appendChild(cell);
*/
              cell = document.createElement("TD");
			  // <button title='Copy to manual input' onclick='destFromLine()'>C</button>
              cell.innerHTML = "<button onclick='clickOnF(" + linesCount + ")' title='Fly to'>F</button>" + 
			  					"<button onclick='openMoonCalc(" + linesCount + ")' title='Open related Mooncalc page'>MC</button>";
              cell.setAttribute("style","text-align: center;");
              row.appendChild(cell);



              row.childNodes.forEach((child) => { // detect mouse events on cells, because events on parent row is not directly detectable
                child.addEventListener("mouseover", function(cell) {
                  var parentRow = cell.srcElement.parentNode;
                  lineNumber = parentRow.id.split("_")[1] * 1; // result_xxx : xxx is the line number
                  highlightLine(myLines[lineNumber]);
                });

                // Upon clicking on a result in table, permanently select the row, highlight the line, show its values, store its data, set camera view...
                child.addEventListener("click", function(cell) {
console.log("CLICK SU TABELLA: ", cell.srcElement.innerText ,cell);	
				if ((cell.srcElement.innerText === "F") || (cell.srcElement.innerText === "MC")){
console.log("Pulsante F, esco");				
					return;	// Don't do anything if click is on "F" button
				}
                  var parentRow = cell.srcElement.parentNode;
                  lineNumber = parentRow.id.split("_")[1] * 1; // result_xxx : xxx is the line number

                  bufLineTarget = {
                      lng : myLines[lineNumber].options.myDest.lng,
                      lat : myLines[lineNumber].options.myDest.lat,
                      time : myLines[lineNumber].options.myTime,
                      moonAlt :  myLines[lineNumber].options.myAlt,
                      moonAz :  myLines[lineNumber].options.myAz
                  }  // Store for copying to Cesium if requisted by user.

                  // Draw Moon direction:
                  var mapCenter = mymap.getCenter();
                  var moonDest = destination(mymap.getCenter(),bufLineTarget.moonAz, (100000));
                  moonLine.setLatLngs([[mapCenter.lat,mapCenter.lng],[moonDest.lat, moonDest.lng]]);
                  moonLine.setStyle({color : MOON_LINE_COLOR})

                  // Show data for selected line:
                  spnLinePopup.innerHTML = "SELECTED:<br>" + myLines[lineNumber].options.popupText;

                  // Highlight row in table:
                  selectedLine = lineNumber;
                  highlightLinePermanently(lineNumber);

                });
              });
}



  function cloneMe(num) {
    return num;
  }


  function destination(latlng, heading, distance) {
  // Returns target coordinates ([lat, lng]) given observer latitude, looking direction (heading) and distance (heading in degrees)
      heading = (heading + 360) % 360;
      var rad = Math.PI / 180,
          radInv = 180 / Math.PI,
          R = 6378137, // approximation of Earth's radius
          lon1 = latlng.lng * rad,
          lat1 = latlng.lat * rad,
          rheading = heading * rad,
          sinLat1 = Math.sin(lat1),
          cosLat1 = Math.cos(lat1),
          cosDistR = Math.cos(distance / R),
          sinDistR = Math.sin(distance / R),
          lat2 = Math.asin(sinLat1 * cosDistR + cosLat1 *
              sinDistR * Math.cos(rheading)),
          lon2 = lon1 + Math.atan2(Math.sin(rheading) * sinDistR *
              cosLat1, cosDistR - sinLat1 * Math.sin(lat2));
      lon2 = lon2 * radInv;
      lon2 = lon2 > 180 ? lon2 - 360 : lon2 < -180 ? lon2 + 360 : lon2;
      return L.latLng([lat2 * radInv, lon2]);
  }



  function getAltAz(observer, target) {
    // Returns heading and elevation for target as seen from observer
    // observer: {lat: , lng: }
    // target: {lat: , lng: }

    var pointA = new Cesium.Cartesian3.fromDegrees(observer.lng, observer.lat, observer.height);
    var pointB = new Cesium.Cartesian3.fromDegrees(target.lng, target.lat, target.height);

    const transform=Cesium.Transforms.eastNorthUpToFixedFrame(pointA);
    const positionvector=Cesium.Cartesian3.subtract(pointB,pointA,new Cesium.Cartesian3());
   const vector=Cesium.Matrix4.multiplyByPointAsVector(Cesium.Matrix4.inverse(transform,new Cesium.Matrix4()),positionvector,new Cesium.Cartesian3());
    const direction=Cesium.Cartesian3.normalize(vector,new Cesium.Cartesian3());

    //heading
    const headingRadRaw = Math.atan2(direction.y, direction.x) - Cesium.Math.PI_OVER_TWO;
    const headingRadFixed = Cesium.Math.PI - Cesium.Math.zeroToTwoPi(headingRadRaw);
    const headingDegFixed = Cesium.Math.toDegrees(Cesium.Math.PI - Cesium.Math.zeroToTwoPi(headingRadFixed));

    //pitch
    const pitchRad = Cesium.Math.PI_OVER_TWO - Cesium.Math.acosClamped(direction.z);
    const pitchDeg = Cesium.Math.toDegrees(Cesium.Math.PI_OVER_TWO - Cesium.Math.acosClamped(direction.z));

    if ((headingDegFixed<0)) {
      headingDegFixed2 = - headingDegFixed;
    } else {
      headingDegFixed2 = 360 - headingDegFixed;
    }

    return (
      {
        headingDeg : headingDegFixed2,
        pitchRad      : pitchRad,
        pitchDeg      : pitchDeg,
        originCartesian : pointA,
        destinationCartesian : pointB
      }
    );
}


function getHeight(lat, lng) {
  var cartographic = Cesium.Cartographic.fromDegrees(  lng, lat, 5000, new Cesium.Cartographic());
  var positions = [ cartographic ];
  var promise = Cesium.sampleTerrain(viewer.terrainProvider, 11, positions);
  Cesium.when(promise, function( updatedPositions ) {
    height = updatedPositions[0].height;
  });
}



function cameraUpDirection(amount) {
  // Returns "up" Cartesian3 vector to move camera up w.r.t. terrain, not w.r.t. camera viewing direction
  cameraCartesian = viewer.camera.position;
  cameraCartographic = Cesium.Cartographic.fromCartesian(cameraCartesian);
  cameraCartographic.height += amount;
  raisedCamera =  Cesium.Cartographic.toCartesian(cameraCartographic);
  return (
    {
      upDir : Cesium.Cartesian3.subtract(raisedCamera, cameraCartesian, new Cesium.Cartesian3()),
      upPos : raisedCamera
    }
  );
}

function drawProfile(lng1, lat1, h1, lng2, lat2, h2) {
// draw line over terrain
  startPointCartesian = Cesium.Cartesian3.fromDegrees(lng1, lat1, h1);
  endPointCartesian = Cesium.Cartesian3.fromDegrees(lng2, lat2, h2);

  const count = 30;
  cartesians = new Array(count);
  for (let i = 0; i < count; ++i) {
    const offset = i / (count - 1);
    cartesians[i] = Cesium.Cartesian3.lerp(
      startPointCartesian,
      endPointCartesian,
      offset,
      new Cesium.Cartesian3()
    );

    //var carto = Cesium.Cartographic.fromCartesian(cartesians[i]);
    //console.log(carto.height);
  }

//console.log(cartesians);

scene
    .clampToHeightMostDetailed(cartesians)
    .then(function (clampedCartesians) {
      for (let i = 0; i < count; ++i) {
        viewer.entities.add({
          position: clampedCartesians[i],
          ellipsoid: {
            radii: new Cesium.Cartesian3(0.2, 0.2, 0.2),
            material: Cesium.Color.RED,
          },
        });
      }

      viewer.entities.add({
        polyline: {
          positions: clampedCartesians,
          arcType: Cesium.ArcType.NONE,
          width: 12,
          /*
          material: new Cesium.PolylineOutlineMaterialProperty({
            color: Cesium.Color.YELLOW,
          }),
          depthFailMaterial: new Cesium.PolylineOutlineMaterialProperty(
            {
              color: Cesium.Color.YELLOW,
            }
          ),*/
        },
      });

    });
}


function createMoonSun3dLines() {
  moonLine3d = viewer.entities.add({
    polyline: {
       // This callback updates positions each frame.
/*
        positions : new Cesium.CallbackProperty(function(time, result) {
          var tempDate = Cesium.JulianDate.toDate(time);
          moonData = mooncalcMeeus(tempDate, mymap.getCenter().lat,  mymap.getCenter().lng, 0)
//console.log("Moon=",time,viewer.clock.currentTime,mymap.getCenter().lat, mymap.getCenter().lng, 0, moonData.moonAltitudeRefractionDegrees,   moonData.moonAzimuthDegrees,   moonData.moonDistance*1000,   1, Cesium.Color.WHITE, false);
          moonpos = arrowFromTo(mymap.getCenter().lat, mymap.getCenter().lng, 0, moonData.moonAltitudeDegrees,   moonData.moonAzimuthDegrees,   moonData.moonDistance*1000,   1, Cesium.Color.WHITE, false);
          baseposC3 = Cesium.Cartesian3.fromDegrees(mymap.getCenter().lng, mymap.getCenter().lat);
          moonposC3 = new Cesium.Cartesian3.fromElements(moonpos.x, moonpos.y, moonpos.z);
          return [baseposC3, moonposC3];
        }, false),
*/
      positions: [ ],
      width: 1,
      arcType: Cesium.ArcType.NONE,
      material: new Cesium.PolylineDashMaterialProperty({color: Cesium.Color.WHITE}),
    },
  });

  sunLine3d = viewer.entities.add({
    polyline: {
       // This callback updates positions each frame.
/*        positions : new Cesium.CallbackProperty(function(time, result) {
          var tempDate = Cesium.JulianDate.toDate(time);
          sunData = suncalcMeeus(tempDate, mymap.getCenter().lat,  mymap.getCenter().lng, 0)
          sunpos = arrowFromTo(mymap.getCenter().lat, mymap.getCenter().lng, 0, sunData.sunAltitudeDegrees,   sunData.sunAzimuthDegrees,   A.Solar.earthsunDelta*1000,   1, Cesium.Color.YELLOW, false);
//console.log("SUN=",mymap.getCenter().lat, mymap.getCenter().lng, 0, sunData.sunAltitudeDegrees,   sunData.sunAzimuthDegrees,   A.Solar.earthsunDelta*1000,   1, Cesium.Color.YELLOW, false);
          return [Cesium.Cartesian3.fromDegrees(mymap.getCenter().lng,mymap.getCenter().lat),sunpos];
        }, false),*/
      positions: [ ],
      width: 1,
      arcType: Cesium.ArcType.NONE,
      material: new Cesium.PolylineDashMaterialProperty({color: Cesium.Color.YELLOW}),
    },
  });
}

function setMoonSun3dLines(debug) {	
    var tempDate = Cesium.JulianDate.toDate(viewer.clock.currentTime);	
	if (isNaN(tempDate.secondsOfDay)) {
		console.log("ERRORE DATA!!");
		return;
	}
    moonData = mooncalcMeeus(tempDate, mymap.getCenter().lat,  mymap.getCenter().lng, 0)	
    sunData = suncalcMeeus(tempDate, mymap.getCenter().lat,  mymap.getCenter().lng, 0)

//console.log(mymap.getCenter().lat, mymap.getCenter().lng, 0, moonData.moonAltitudeRefractionDegrees, moonData.moonAzimuthDegrees, moonData.moonDistance*1000, 1, Cesium.Color.WHITE,true, "", false) // debug: non si vede?!?
      moonpos = arrowFromTo(mymap.getCenter().lat, mymap.getCenter().lng, 0, moonData.moonAltitudeRefractionDegrees, moonData.moonAzimuthDegrees, moonData.moonDistance*1000, 1, Cesium.Color.WHITE,false);
      moonLine3d.polyline.positions.setValue([Cesium.Cartesian3.fromDegrees(mymap.getCenter().lng,mymap.getCenter().lat),moonpos])
//console.log(mymap.getCenter().lat, mymap.getCenter().lng, 0, sunData.sunAltitudeDegrees,   sunData.sunAzimuthDegrees,   A.Solar.earthsunDelta*1000,   1, Cesium.Color.YELLOW,true, "", false)
      sunpos = arrowFromTo(mymap.getCenter().lat, mymap.getCenter().lng, 0, sunData.sunAltitudeDegrees,   sunData.sunAzimuthDegrees,   A.Solar.earthsunDelta*1000,   1, Cesium.Color.YELLOW, false)
      sunLine3d.polyline.positions.setValue([Cesium.Cartesian3.fromDegrees(mymap.getCenter().lng,mymap.getCenter().lat),sunpos])

  if (typeof debug !== "undefined") {
    console.log(moonData, sunData );
  }


}


///////////// debug test //////////////

function RAdecToAltAz(eqcoordRaw, eclCoord, dateJS)  {
/*
                * @param {EqCoord} eqcoord - equatorial coordinates, in radians {ra, dec}
                * @param {EclCoord} latlng - ecliptic coordinates of observer on Earth {lat, lng}
                * @param {number} st - sidereal time at Greenwich at time of observation in radians.
*/

  eqcoord = {ra: eqcoordRaw.rightAscension, dec: eqcoordRaw.declination };

    strad = g_sidereal(dateJS.getFullYear(),dateJS.getMonth()+1.0,dateJS.getDate());

                               var H = strad - eclCoord.lng - eqcoord.ra; // ra = Right Ascension (alpha)

                               var sH = Math.sin(H); // H = hour angle
                               var cH = Math.cos(H);
                               var slat = Math.sin(eclCoord.lat);         // lat = latitude (phi)
                               var clat = Math.cos(eclCoord.lat);
                               var sdec = Math.sin(eqcoord.dec);          // dec = declination (delta)
                               var cdec = Math.cos(eqcoord.dec);

                               return {
                                               // Meeus citation:
                                               // "If one wishes to reckon the azimuth from the North instead of the South,
                                               // add 180 degrees to the first value"
                                               az : Math.atan2(sH, cH * slat - (sdec / cdec) * clat) + Math.PI,    //  Azimuth  - (13.5) p. 93
                                               alt : Math.asin(slat * sdec + clat * cdec * cH)            //  Altitude - (13.6) p. 93
                               };
}


function g_sidereal(year,month,day) {
// http://www.stargazing.net/mas/hayes/ephemeris/datetime.js
  var T=(jd0(year,month,day)-2451545.0)/36525;
  var res=100.46061837+T*(36000.770053608+T*(0.000387933-T/38710000.0));
  return rev(res)/15.0;
}


// The Julian date at 0 hours UT at Greenwich
// http://www.stargazing.net/mas/hayes/ephemeris/datetime.js
function jd0(year,month,day) {
  var y  = year;
  var m = month;
  if (m < 3) {m += 12; y -= 1};
  var a = Math.floor(y/100);
  var b = 2-a+Math.floor(a/4);
  var j = Math.floor(365.25*(y+4716))+Math.floor(30.6001*(m+1))+day+b-1524.5;
  return j;
}

function rev(angle){return angle-Math.floor(angle/360.0)*360.0;} // http://www.stargazing.net/mas/hayes/ephemeris/math.js

/////////////// end test ///////////////



function CalcPosFromAltAzDist(startPoint, vectorPointing) {

  var ellipsoid = Cesium.Ellipsoid.WGS84;
  var ENU = new Cesium.Matrix4();
  Cesium.Transforms.eastNorthUpToFixedFrame(startPoint,ellipsoid,ENU);
  var myX = vectorPointing.dist * Math.cos(vectorPointing.alt * Math.PI / 180)* Math.sin(vectorPointing.az * Math.PI / 180);
  var myY = vectorPointing.dist * Math.cos(vectorPointing.alt * Math.PI / 180)* Math.cos(vectorPointing.az * Math.PI / 180);
  var myZ = vectorPointing.dist * Math.sin(vectorPointing.alt * Math.PI / 180);
  var offset = new Cesium.Cartesian3(myX,myY,myZ);
  var finalPoint = Cesium.Matrix4.multiplyByPoint(ENU, offset, new Cesium.Cartesian3());
  return finalPoint;

}

function getMapEdges(map, debugDraw) {
  var B = map.getBounds();
  var NW = B.getNorthWest();
  var NE = B.getNorthEast();
  var SE = B.getSouthEast();
  var SW = B.getSouthWest();
  if (debugDraw) {
   var tempTop =  L.polyline(
    [NW, NE],
    {weight : 3},
    ).addTo(map);

    var tempRight =  L.polyline(
     [NE, SE],
    {weight : 3},
    ).addTo(map);

    var tempBottom =  L.polyline(
    [SW, SE],
    {weight : 3},
    ).addTo(map);

    var tempLeft =  L.polyline(
    [NW, SW],
    {weight : 3},
    ).addTo(map);
  }
return {
    top:      [NW, NE],
    right :   [NE, SE],
    bottom :  [SW, SE],
    left :    [NW, SW]
  }
}


function intersect(edgePoints, line, drawDebug, map, tooltipName) {

  var x1 = edgePoints[0].lng
  var y1 = edgePoints[0].lat
  var x2 = edgePoints[1].lng
  var y2 = edgePoints[1].lat

  var x3 = line.getLatLngs()[0].lng
  var y3 = line.getLatLngs()[0].lat
  var x4 = line.getLatLngs()[1].lng
  var y4 = line.getLatLngs()[1].lat

    // Check if none of the lines are of length 0
    if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {
        return { err : "zero line"}
    }

    const denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1))

    // Lines are parallel
    if (denominator === 0) {
        return {err: "parallel"}
    }

    let ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator
    let ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator

    // Return a object with the x and y coordinates of the intersection
    let x = x1 + ua * (x2 - x1)
    let y = y1 + ua * (y2 - y1)

    if (drawDebug) {
      map.openTooltip(tooltipName, { lng: x, lat: y });
      var tempLine = L.polyline(
       [[x3,y3],
       [x4,y4]],
       {weight : 15},
      ).addTo(moonLineLayer);
    }

   if ((ua >= 0 && ua <= 1) && (ub >= 0 && ub <= 1))  {
       Intersez2Segm = true
   } else {
       Intersez2Segm = false
   }

/*console.log(tooltipName);
console.log(x1,x,x2, "---", x3,x,x4 );
console.log(y1,y,y2, "---", y3,y,y4);
console.log("^^^^^^^^^");
*/
    return {
      lng: x,
      lat: y,
      inters:  Intersez2Segm
    }
}

function getURLParameters() {
  var params = {};
  var url = window.location.href;
  var paramArray = url.slice(url.indexOf('?') + 1).split('&');

  for (var i = 0; i < paramArray.length; i++) {
    var param = paramArray[i].split('=');
    params[param[0]] = param[1];
  }

  return params;
}

function populateInterfaceFromURL(urlParams) {
console.log("urlParams",urlParams);
  document.getElementById("flyLocGoogle").value = urlParams.inputLat + ", " + urlParams.inputLon + ", " + urlParams.inputAlt;
  document.getElementById("rngHeight").value = urlParams.inputAlt;
  document.getElementById("flyaz").value = urlParams.inputAz;
  document.getElementById("flyel").value = urlParams.inputPitch;
  document.getElementById("resultDate").value = urlParams.currentTime;
  document.getElementById("rngZoom").value = urlParams.zoom;
  document.getElementById("spnCameraZoom").value = urlParams.zoom;
  //document.getElementById("spnCameraHeight").value = urlParams.inputAlt;
}




</script>


</body>
</html>
